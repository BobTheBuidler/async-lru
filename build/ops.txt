def _CacheItem.cancel(self):
    self :: faster_async_lru._CacheItem
    r0 :: union[object, None]
    r1 :: object
    r2 :: bit
    r3 :: union[object, None]
    r4 :: object
    r5 :: str
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9 :: None
    r10 :: object
    r11 :: bool
    r12 :: None
L0:
    r0 = borrow self.later_call
    if is_error(r0) goto L8 (error at cancel:75) else goto L1
L1:
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L2 else goto L7 :: bool
L2:
    r3 = self.later_call
    if is_error(r3) goto L8 (error at cancel:76) else goto L3
L3:
    r4 = r3
    r5 = 'cancel'
    r6 = [r4]
    r7 = load_address r6
    r8 = PyObject_VectorcallMethod(r5, r7, 9223372036854775809, 0)
    if is_error(r8) goto L9 (error at cancel:76) else goto L4
L4:
    dec_ref r4
    r9 = unbox(None, r8)
    dec_ref r8
    if is_error(r9) goto L8 (error at cancel:76) else goto L5
L5:
L6:
    r10 = box(None, 1)
    inc_ref r10
    self.later_call = r10; r11 = is_error
    if not r11 goto L8 (error at cancel:77) else goto L7 :: bool
L7:
    return 1
L8:
    r12 = <error> :: None
    return r12
L9:
    dec_ref r4
    goto L8

def _LRUCacheWrapper.__init__(self, fn, maxsize, typed, ttl):
    self :: faster_async_lru._LRUCacheWrapper
    fn :: object
    maxsize :: union[int, None]
    typed :: bool
    ttl :: union[float, None]
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: bool
    r4 :: tuple[object, object, object]
    r5 :: object
    r6 :: str
    r7 :: object
    r8, r9 :: bit
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: bool
    r14 :: tuple[object, object, object]
    r15 :: object
    r16 :: str
    r17 :: object
    r18, r19 :: bit
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: bool
    r24 :: tuple[object, object, object]
    r25 :: object
    r26 :: str
    r27 :: object
    r28, r29 :: bit
    r30 :: str
    r31 :: object
    r32 :: union[str, None]
    r33 :: bool
    r34 :: tuple[object, object, object]
    r35 :: object
    r36 :: str
    r37 :: object
    r38, r39 :: bit
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: bool
    r44 :: tuple[object, object, object]
    r45 :: object
    r46 :: str
    r47 :: object
    r48, r49 :: bit
    r50 :: str
    r51 :: object
    r52, r53 :: dict
    r54 :: bool
    r55 :: tuple[object, object, object]
    r56 :: object
    r57 :: str
    r58 :: object
    r59, r60 :: bit
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: tuple
    r65 :: tuple[int, int]
    r66, r67 :: object
    r68 :: bool
    r69 :: dict
    r70 :: str
    r71 :: object
    r72, r73, r74, r75, r76 :: bool
    r77 :: dict
    r78 :: str
    r79, r80 :: object
    r81 :: dict
    r82, r83, r84, r85 :: bool
    r86 :: set
    r87 :: bool
    r88 :: None
L0:
L1:
    r0 = '__module__'
    r1 = CPyObject_GetAttr(fn, r0)
    if is_error(r1) goto L4 (error at __init__:90) else goto L2
L2:
    r2 = cast(str, r1)
    if is_error(r2) goto L4 (error at __init__:90) else goto L3
L3:
    self.__module__ = r2; r3 = is_error
    if not r3 goto L4 (error at __init__:90) else goto L11 :: bool
L4:
    r4 = CPy_CatchError()
    r5 = builtins :: module
    r6 = 'AttributeError'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L9 (error at __init__:91) else goto L5
L5:
    r8 = CPy_ExceptionMatches(r7)
    dec_ref r7
    if r8 goto L8 else goto L6 :: bool
L6:
    CPy_Reraise()
    if not 0 goto L9 else goto L84 :: bool
L7:
    unreachable
L8:
    CPy_RestoreExcInfo(r4)
    dec_ref r4
    goto L11
L9:
    CPy_RestoreExcInfo(r4)
    dec_ref r4
    r9 = CPy_KeepPropagating()
    if not r9 goto L83 else goto L10 :: bool
L10:
    unreachable
L11:
    r10 = '__name__'
    r11 = CPyObject_GetAttr(fn, r10)
    if is_error(r11) goto L14 (error at __init__:94) else goto L12
L12:
    r12 = cast(str, r11)
    if is_error(r12) goto L14 (error at __init__:94) else goto L13
L13:
    self.__name__ = r12; r13 = is_error
    if not r13 goto L14 (error at __init__:94) else goto L21 :: bool
L14:
    r14 = CPy_CatchError()
    r15 = builtins :: module
    r16 = 'AttributeError'
    r17 = CPyObject_GetAttr(r15, r16)
    if is_error(r17) goto L19 (error at __init__:95) else goto L15
L15:
    r18 = CPy_ExceptionMatches(r17)
    dec_ref r17
    if r18 goto L18 else goto L16 :: bool
L16:
    CPy_Reraise()
    if not 0 goto L19 else goto L85 :: bool
L17:
    unreachable
L18:
    CPy_RestoreExcInfo(r14)
    dec_ref r14
    goto L21
L19:
    CPy_RestoreExcInfo(r14)
    dec_ref r14
    r19 = CPy_KeepPropagating()
    if not r19 goto L83 else goto L20 :: bool
L20:
    unreachable
L21:
    r20 = '__qualname__'
    r21 = CPyObject_GetAttr(fn, r20)
    if is_error(r21) goto L24 (error at __init__:98) else goto L22
L22:
    r22 = cast(str, r21)
    if is_error(r22) goto L24 (error at __init__:98) else goto L23
L23:
    self.__qualname__ = r22; r23 = is_error
    if not r23 goto L24 (error at __init__:98) else goto L31 :: bool
L24:
    r24 = CPy_CatchError()
    r25 = builtins :: module
    r26 = 'AttributeError'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L29 (error at __init__:99) else goto L25
L25:
    r28 = CPy_ExceptionMatches(r27)
    dec_ref r27
    if r28 goto L28 else goto L26 :: bool
L26:
    CPy_Reraise()
    if not 0 goto L29 else goto L86 :: bool
L27:
    unreachable
L28:
    CPy_RestoreExcInfo(r24)
    dec_ref r24
    goto L31
L29:
    CPy_RestoreExcInfo(r24)
    dec_ref r24
    r29 = CPy_KeepPropagating()
    if not r29 goto L83 else goto L30 :: bool
L30:
    unreachable
L31:
    r30 = '__doc__'
    r31 = CPyObject_GetAttr(fn, r30)
    if is_error(r31) goto L34 (error at __init__:102) else goto L32
L32:
    r32 = cast(union[str, None], r31)
    if is_error(r32) goto L34 (error at __init__:102) else goto L33
L33:
    self.__doc__ = r32; r33 = is_error
    if not r33 goto L34 (error at __init__:102) else goto L41 :: bool
L34:
    r34 = CPy_CatchError()
    r35 = builtins :: module
    r36 = 'AttributeError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L39 (error at __init__:103) else goto L35
L35:
    r38 = CPy_ExceptionMatches(r37)
    dec_ref r37
    if r38 goto L38 else goto L36 :: bool
L36:
    CPy_Reraise()
    if not 0 goto L39 else goto L87 :: bool
L37:
    unreachable
L38:
    CPy_RestoreExcInfo(r34)
    dec_ref r34
    goto L41
L39:
    CPy_RestoreExcInfo(r34)
    dec_ref r34
    r39 = CPy_KeepPropagating()
    if not r39 goto L83 else goto L40 :: bool
L40:
    unreachable
L41:
    r40 = '__annotations__'
    r41 = CPyObject_GetAttr(fn, r40)
    if is_error(r41) goto L44 (error at __init__:106) else goto L42
L42:
    r42 = cast(dict, r41)
    if is_error(r42) goto L44 (error at __init__:106) else goto L43
L43:
    self.__annotations__ = r42; r43 = is_error
    if not r43 goto L44 (error at __init__:106) else goto L51 :: bool
L44:
    r44 = CPy_CatchError()
    r45 = builtins :: module
    r46 = 'AttributeError'
    r47 = CPyObject_GetAttr(r45, r46)
    if is_error(r47) goto L49 (error at __init__:107) else goto L45
L45:
    r48 = CPy_ExceptionMatches(r47)
    dec_ref r47
    if r48 goto L48 else goto L46 :: bool
L46:
    CPy_Reraise()
    if not 0 goto L49 else goto L88 :: bool
L47:
    unreachable
L48:
    CPy_RestoreExcInfo(r44)
    dec_ref r44
    goto L51
L49:
    CPy_RestoreExcInfo(r44)
    dec_ref r44
    r49 = CPy_KeepPropagating()
    if not r49 goto L83 else goto L50 :: bool
L50:
    unreachable
L51:
    r50 = '__dict__'
    r51 = CPyObject_GetAttr(fn, r50)
    if is_error(r51) goto L55 (error at __init__:110) else goto L52
L52:
    r52 = cast(dict, r51)
    if is_error(r52) goto L55 (error at __init__:110) else goto L53
L53:
    r53 = PyDict_Copy(r52)
    dec_ref r52
    if is_error(r53) goto L55 (error at __init__:110) else goto L54
L54:
    self.__dict__ = r53; r54 = is_error
    if not r54 goto L55 (error at __init__:110) else goto L62 :: bool
L55:
    r55 = CPy_CatchError()
    r56 = builtins :: module
    r57 = 'AttributeError'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L60 (error at __init__:111) else goto L56
L56:
    r59 = CPy_ExceptionMatches(r58)
    dec_ref r58
    if r59 goto L59 else goto L57 :: bool
L57:
    CPy_Reraise()
    if not 0 goto L60 else goto L89 :: bool
L58:
    unreachable
L59:
    CPy_RestoreExcInfo(r55)
    dec_ref r55
    goto L62
L60:
    CPy_RestoreExcInfo(r55)
    dec_ref r55
    r60 = CPy_KeepPropagating()
    if not r60 goto L83 else goto L61 :: bool
L61:
    unreachable
L62:
    r61 = sys :: module
    r62 = 'version_info'
    r63 = CPyObject_GetAttr(r61, r62)
    if is_error(r63) goto L83 (error at __init__:115) else goto L63
L63:
    r64 = cast(tuple, r63)
    if is_error(r64) goto L83 (error at __init__:115) else goto L64
L64:
    r65 = (6, 28)
    r66 = box(tuple[int, int], r65)
    r67 = PyObject_RichCompare(r64, r66, 0)
    dec_ref r64
    dec_ref r66
    if is_error(r67) goto L83 (error at __init__:115) else goto L65
L65:
    r68 = unbox(bool, r67)
    dec_ref r67
    if is_error(r68) goto L83 (error at __init__:115) else goto L66
L66:
    if r68 goto L67 else goto L69 :: bool
L67:
    r69 = faster_async_lru.globals :: static
    r70 = '_is_coroutine'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L83 (error at __init__:116) else goto L68
L68:
    self._is_coroutine = r71; r72 = is_error
    if not r72 goto L83 (error at __init__:116) else goto L69 :: bool
L69:
    inc_ref fn
    self.__wrapped__ = fn; r73 = is_error
    if not r73 goto L83 (error at __init__:117) else goto L70 :: bool
L70:
    inc_ref maxsize
    self.__maxsize = maxsize; r74 = is_error
    if not r74 goto L83 (error at __init__:118) else goto L71 :: bool
L71:
    self.__typed = typed; r75 = is_error
    if not r75 goto L83 (error at __init__:119) else goto L72 :: bool
L72:
    inc_ref ttl
    self.__ttl = ttl; r76 = is_error
    if not r76 goto L83 (error at __init__:120) else goto L73 :: bool
L73:
    r77 = faster_async_lru.globals :: static
    r78 = 'OrderedDict'
    r79 = CPyDict_GetItem(r77, r78)
    if is_error(r79) goto L83 (error at __init__:121) else goto L74
L74:
    r80 = PyObject_Vectorcall(r79, 0, 0, 0)
    dec_ref r79
    if is_error(r80) goto L83 (error at __init__:121) else goto L75
L75:
    r81 = cast(dict, r80)
    if is_error(r81) goto L83 (error at __init__:121) else goto L76
L76:
    self.__cache = r81; r82 = is_error
    if not r82 goto L83 (error at __init__:121) else goto L77 :: bool
L77:
    self.__closed = 0; r83 = is_error
    if not r83 goto L83 (error at __init__:122) else goto L78 :: bool
L78:
    self.__hits = 0; r84 = is_error
    if not r84 goto L83 (error at __init__:123) else goto L79 :: bool
L79:
    self.__misses = 0; r85 = is_error
    if not r85 goto L83 (error at __init__:124) else goto L80 :: bool
L80:
    r86 = PySet_New(0)
    if is_error(r86) goto L83 (error at __init__:125) else goto L81
L81:
    self.__tasks = r86; r87 = is_error
    if not r87 goto L83 (error at __init__:125) else goto L82 :: bool
L82:
    return 1
L83:
    r88 = <error> :: None
    return r88
L84:
    dec_ref r4
    goto L7
L85:
    dec_ref r14
    goto L17
L86:
    dec_ref r24
    goto L27
L87:
    dec_ref r34
    goto L37
L88:
    dec_ref r44
    goto L47
L89:
    dec_ref r55
    goto L58

def _LRUCacheWrapper.cache_invalidate(self, args, kwargs):
    self :: faster_async_lru._LRUCacheWrapper
    args :: tuple
    kwargs :: dict
    r0 :: bool
    r1 :: union[str, int, faster_async_lru._HashedSeq]
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: union[faster_async_lru._CacheItem, None]
    r9 :: object
    r10 :: bit
    r11 :: faster_async_lru._CacheItem
    r12 :: None
    r13 :: bool
L0:
    r0 = self.__typed
    if is_error(r0) goto L10 (error at cache_invalidate:128) else goto L1
L1:
    r1 = _make_key(args, kwargs, r0)
    if is_error(r1) goto L10 (error at cache_invalidate:128) else goto L2
L2:
    r2 = self.__cache
    if is_error(r2) goto L11 (error at cache_invalidate:130) else goto L3
L3:
    r3 = 'pop'
    r4 = box(None, 1)
    r5 = [r2, r1, r4]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r3, r6, 9223372036854775811, 0)
    if is_error(r7) goto L12 (error at cache_invalidate:130) else goto L4
L4:
    dec_ref r2
    dec_ref r1
    r8 = cast(union[faster_async_lru._CacheItem, None], r7)
    if is_error(r8) goto L10 (error at cache_invalidate:130) else goto L5
L5:
    r9 = load_address _Py_NoneStruct
    r10 = r8 == r9
    if r10 goto L13 else goto L7 :: bool
L6:
    return 0
L7:
    r11 = cast(faster_async_lru._CacheItem, r8)
    if is_error(r11) goto L10 (error at cache_invalidate:134) else goto L8
L8:
    r12 = r11.cancel()
    dec_ref r11
    if is_error(r12) goto L10 (error at cache_invalidate:134) else goto L9
L9:
    return 1
L10:
    r13 = <error> :: bool
    return r13
L11:
    dec_ref r1
    goto L10
L12:
    dec_ref r1
    dec_ref r2
    goto L10
L13:
    dec_ref r8
    goto L6

def _LRUCacheWrapper.cache_clear(self):
    self :: faster_async_lru._LRUCacheWrapper
    r0, r1 :: bool
    r2 :: dict
    r3 :: short_int
    r4 :: native_int
    r5 :: object
    r6 :: tuple[bool, short_int, object]
    r7 :: short_int
    r8 :: bool
    r9 :: object
    r10 :: faster_async_lru._CacheItem
    r11 :: union[object, None]
    r12 :: object
    r13 :: bit
    r14 :: object
    r15 :: i32
    r16 :: bit
    r17 :: bool
    r18 :: union[object, None]
    r19 :: object
    r20 :: str
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: None
    r25, r26 :: bit
    r27 :: dict
    r28 :: bit
    r29 :: set
    r30 :: i32
    r31 :: bit
    r32 :: None
L0:
    self.__hits = 0; r0 = is_error
    if not r0 goto L22 (error at cache_clear:138) else goto L1 :: bool
L1:
    self.__misses = 0; r1 = is_error
    if not r1 goto L22 (error at cache_clear:139) else goto L2 :: bool
L2:
    r2 = self.__cache
    if is_error(r2) goto L22 (error at cache_clear:141) else goto L3
L3:
    r3 = 0
    r4 = PyDict_Size(r2)
    r5 = CPyDict_GetValuesIter(r2)
    if is_error(r5) goto L23 (error at cache_clear:141) else goto L4
L4:
    r6 = CPyDict_NextValue(r5, r3)
    r7 = r6[1]
    r3 = r7
    r8 = r6[0]
    if r8 goto L5 else goto L24 :: bool
L5:
    r9 = r6[2]
    dec_ref r6
    r10 = cast(faster_async_lru._CacheItem, r9)
    if is_error(r10) goto L25 (error at cache_clear:141) else goto L6
L6:
    r11 = r10.later_call
    if is_error(r11) goto L26 (error at cache_clear:142) else goto L7
L7:
    r12 = load_address _Py_NoneStruct
    r13 = r11 != r12
    if r13 goto L8 else goto L27 :: bool
L8:
    r14 = cast(object, r11)
    if is_error(r14) goto L26 (error at cache_clear:142) else goto L9
L9:
    r15 = PyObject_IsTrue(r14)
    dec_ref r14
    r16 = r15 >= 0 :: signed
    if not r16 goto L26 (error at cache_clear:142) else goto L10 :: bool
L10:
    r17 = truncate r15: i32 to builtins.bool
    if r17 goto L11 else goto L28 :: bool
L11:
    r18 = r10.later_call
    dec_ref r10
    if is_error(r18) goto L25 (error at cache_clear:143) else goto L12
L12:
    r19 = r18
    r20 = 'cancel'
    r21 = [r19]
    r22 = load_address r21
    r23 = PyObject_VectorcallMethod(r20, r22, 9223372036854775809, 0)
    if is_error(r23) goto L29 (error at cache_clear:143) else goto L13
L13:
    dec_ref r19
    r24 = unbox(None, r23)
    dec_ref r23
    if is_error(r24) goto L25 (error at cache_clear:143) else goto L14
L14:
L15:
    r25 = CPyDict_CheckSize(r2, r4)
    if not r25 goto L25 (error at cache_clear:141) else goto L4 :: bool
L16:
    r26 = CPy_NoErrOccurred()
    if not r26 goto L22 (error at cache_clear:141) else goto L17 :: bool
L17:
    r27 = self.__cache
    if is_error(r27) goto L22 (error at cache_clear:144) else goto L18
L18:
    r28 = CPyDict_Clear(r27)
    dec_ref r27
    if not r28 goto L22 (error at cache_clear:144) else goto L19 :: bool
L19:
    r29 = self.__tasks
    if is_error(r29) goto L22 (error at cache_clear:145) else goto L20
L20:
    r30 = PySet_Clear(r29)
    dec_ref r29
    r31 = r30 >= 0 :: signed
    if not r31 goto L22 (error at cache_clear:145) else goto L21 :: bool
L21:
    return 1
L22:
    r32 = <error> :: None
    return r32
L23:
    dec_ref r2
    goto L22
L24:
    dec_ref r2
    dec_ref r5
    dec_ref r6
    goto L16
L25:
    dec_ref r2
    dec_ref r5
    goto L22
L26:
    dec_ref r2
    dec_ref r5
    dec_ref r10
    goto L22
L27:
    dec_ref r10
    dec_ref r11
    goto L15
L28:
    dec_ref r10
    goto L15
L29:
    dec_ref r2
    dec_ref r5
    dec_ref r19
    goto L22

def cache_close__LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1 :: object
    r2 :: i32
    r3 :: object
    r4 :: bit
    r5 :: faster_async_lru._LRUCacheWrapper
    r6 :: bool
    r7 :: faster_async_lru._LRUCacheWrapper
    r8 :: set
    r9 :: list
    r10 :: bool
    r11 :: list
    r12 :: ptr
    r13 :: native_int
    r14 :: short_int
    r15 :: bit
    r16 :: object
    r17, r18 :: bool
    r19 :: list
    r20, r21 :: bool
    r22 :: list
    r23 :: ptr
    r24, r25 :: native_int
    r26 :: bit
    r27 :: list
    r28 :: native_int
    r29, r30 :: ptr
    r31 :: native_int
    r32 :: ptr
    r33 :: object
    r34 :: bool
    r35 :: object
    r36 :: str
    r37 :: object[1]
    r38 :: object_ptr
    r39 :: object
    r40 :: bool
    r41 :: object
    r42 :: str
    r43 :: object[1]
    r44 :: object_ptr
    r45 :: object
    r46, r47 :: native_int
    r48 :: bool
    r49 :: list
    r50 :: object
    r51 :: bool
    r52 :: list
    r53 :: object
    r54 :: str
    r55 :: tuple
    r56 :: object
    r57 :: dict
    r58, r59 :: object
    r60 :: bool
    r61, r62, r63, r64, r65 :: object
    r66 :: bool
    r67 :: object
    r68 :: bool
    r69 :: object
    r70 :: bit
    r71 :: tuple[object, object, object]
    r72 :: bool
    r73 :: object_ptr
    r74 :: object
    r75 :: bool
    r76, r77, r78 :: tuple[object, object, object]
    r79 :: bit
    r80, r81, r82, r83 :: object
    r84 :: bool
    r85, r86 :: bit
    r87 :: bool
    r88 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_next_label__
    goto L79
L1:
    r3 = load_address _Py_NoneStruct
    r4 = type != r3
    if r4 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L83 (error at cache_close:147) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r5) goto L83 (error at cache_close:148) else goto L5
L5:
    r5.__closed = 1; r6 = is_error
    dec_ref r5
    if not r6 goto L83 (error at cache_close:148) else goto L6 :: bool
L6:
    r7 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r7) goto L83 (error at cache_close:150) else goto L7
L7:
    r8 = r7.__tasks
    dec_ref r7
    if is_error(r8) goto L83 (error at cache_close:150) else goto L8
L8:
    r9 = PySequence_List(r8)
    dec_ref r8
    if is_error(r9) goto L83 (error at cache_close:150) else goto L9
L9:
    __mypyc_self__.__mypyc_generator_attribute__tasks = r9; r10 = is_error
    if not r10 goto L83 (error at cache_close:150) else goto L10 :: bool
L10:
    r11 = __mypyc_self__.__mypyc_generator_attribute__tasks
    if is_error(r11) goto L83 (error at cache_close:151) else goto L11
L11:
    r12 = get_element_ptr r11 ob_size :: PyVarObject
    r13 = load_mem r12 :: native_int*
    dec_ref r11
    r14 = r13 << 1
    r15 = r14 != 0
    if r15 goto L17 else goto L12 :: bool
L12:
    r16 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L13:
    if is_error(stop_iter_ptr) goto L14 else goto L16
L14:
    CPyGen_SetStopIterationValue(r16)
    if not 0 goto L83 else goto L15 :: bool
L15:
    unreachable
L16:
    inc_ref r16
    set_mem stop_iter_ptr, r16 :: builtins.object*
    return 0
L17:
    r18 = __mypyc_self__.__mypyc_generator_attribute__wait
    if is_error(r18) goto L83 (error at cache_close:154) else goto L18
L18:
    if r18 goto L37 else goto L19 :: bool
L19:
    r19 = __mypyc_self__.__mypyc_generator_attribute__tasks
    if is_error(r19) goto L83 (error at cache_close:155) else goto L20
L20:
    __mypyc_self__.__mypyc_temp__0 = r19; r20 = is_error
    if not r20 goto L83 (error at cache_close:-1) else goto L21 :: bool
L21:
    __mypyc_self__.__mypyc_temp__1 = 0; r21 = is_error
    if not r21 goto L83 (error at cache_close:-1) else goto L22 :: bool
L22:
    r22 = __mypyc_self__.__mypyc_temp__0
    if is_error(r22) goto L83 (error at cache_close:155) else goto L23
L23:
    r23 = get_element_ptr r22 ob_size :: PyVarObject
    r24 = load_mem r23 :: native_int*
    dec_ref r22
    r25 = __mypyc_self__.__mypyc_temp__1
    if is_error(r25) goto L83 (error at cache_close:155) else goto L24
L24:
    r26 = r25 < r24 :: signed
    if r26 goto L25 else goto L37 :: bool
L25:
    r27 = __mypyc_self__.__mypyc_temp__0
    if is_error(r27) goto L83 (error at cache_close:155) else goto L26
L26:
    r28 = __mypyc_self__.__mypyc_temp__1
    if is_error(r28) goto L84 (error at cache_close:155) else goto L27
L27:
    r29 = get_element_ptr r27 ob_item :: PyListObject
    r30 = load_mem r29 :: ptr*
    r31 = r28 * 8
    r32 = r30 + r31
    r33 = load_mem r32 :: builtins.object*
    dec_ref r27
    __mypyc_self__.__mypyc_generator_attribute__task = r33; r34 = is_error
    if not r34 goto L83 (error at cache_close:155) else goto L28 :: bool
L28:
    r35 = __mypyc_self__.__mypyc_generator_attribute__task
    if is_error(r35) goto L83 (error at cache_close:156) else goto L29
L29:
    r36 = 'done'
    r37 = [r35]
    r38 = load_address r37
    r39 = PyObject_VectorcallMethod(r36, r38, 9223372036854775809, 0)
    if is_error(r39) goto L85 (error at cache_close:156) else goto L30
L30:
    dec_ref r35
    r40 = unbox(bool, r39)
    dec_ref r39
    if is_error(r40) goto L83 (error at cache_close:156) else goto L31
L31:
    if r40 goto L35 else goto L32 :: bool
L32:
    r41 = __mypyc_self__.__mypyc_generator_attribute__task
    if is_error(r41) goto L83 (error at cache_close:157) else goto L33
L33:
    r42 = 'cancel'
    r43 = [r41]
    r44 = load_address r43
    r45 = PyObject_VectorcallMethod(r42, r44, 9223372036854775809, 0)
    if is_error(r45) goto L86 (error at cache_close:157) else goto L87
L34:
    dec_ref r41
L35:
    r46 = __mypyc_self__.__mypyc_temp__1
    if is_error(r46) goto L83 (error at cache_close:155) else goto L36
L36:
    r47 = r46 + 1
    __mypyc_self__.__mypyc_temp__1 = r47; r48 = is_error
    if not r48 goto L83 (error at cache_close:155) else goto L22 :: bool
L37:
    r49 = __mypyc_self__.__mypyc_generator_attribute__tasks
    if is_error(r49) goto L83 (error at cache_close:159) else goto L38
L38:
    r50 = faster_async_lru.gather :: static
    if is_error(r50) goto L88 else goto L41
L39:
    r51 = raise NameError('value for final name "gather" was not set')
    if not r51 goto L83 (error at cache_close:159) else goto L40 :: bool
L40:
    unreachable
L41:
    r52 = PyList_New(0)
    if is_error(r52) goto L89 (error at cache_close:159) else goto L42
L42:
    r53 = CPyList_Extend(r52, r49)
    dec_ref r49
    if is_error(r53) goto L90 (error at cache_close:159) else goto L91
L43:
    r54 = 'return_exceptions'
    r55 = PyList_AsTuple(r52)
    dec_ref r52
    if is_error(r55) goto L83 (error at cache_close:159) else goto L44
L44:
    r56 = box(bool, 1)
    r57 = CPyDict_Build(1, r54, r56)
    if is_error(r57) goto L92 (error at cache_close:159) else goto L45
L45:
    r58 = PyObject_Call(r50, r55, r57)
    dec_ref r55
    dec_ref r57
    if is_error(r58) goto L83 (error at cache_close:159) else goto L46
L46:
    r59 = CPy_GetCoro(r58)
    dec_ref r58
    if is_error(r59) goto L83 (error at cache_close:159) else goto L47
L47:
    __mypyc_self__.__mypyc_temp__2 = r59; r60 = is_error
    if not r60 goto L83 (error at cache_close:-1) else goto L48 :: bool
L48:
    r61 = __mypyc_self__.__mypyc_temp__2
    if is_error(r61) goto L83 (error at cache_close:-1) else goto L49
L49:
    r62 = CPyIter_Next(r61)
    dec_ref r61
    if is_error(r62) goto L50 else goto L52
L50:
    r63 = CPy_FetchStopIterationValue()
    if is_error(r63) goto L83 (error at cache_close:159) else goto L51
L51:
    r64 = r63
    dec_ref r64
    r65 = <error> :: object
    __mypyc_self__.__mypyc_temp__2 = r65; r66 = is_error
    if not r66 goto L83 (error at cache_close:159) else goto L74 :: bool
L52:
    r67 = r62
L53:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r67
L54:
    r69 = load_address _Py_NoneStruct
    r70 = type != r69
    if r70 goto L55 else goto L93 :: bool
L55:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L58 (error at cache_close:159) else goto L94 :: bool
L56:
    unreachable
L57:
    inc_ref arg
    goto L69
L58:
    r71 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__3 = r71; r72 = is_error
    if not r72 goto L95 (error at cache_close:-1) else goto L59 :: bool
L59:
    r73 = load_address r1
    r74 = __mypyc_self__.__mypyc_temp__2
    if is_error(r74) goto L95 (error at cache_close:-1) else goto L60
L60:
    r75 = CPy_YieldFromErrorHandle(r74, r73)
    dec_ref r74
    if is_error(r75) goto L95 (error at cache_close:159) else goto L61
L61:
    if r75 goto L64 else goto L62 :: bool
L62:
    r67 = r1
    r76 = __mypyc_self__.__mypyc_temp__3
    if is_error(r76) goto L96 (error at cache_close:-1) else goto L63
L63:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    goto L53
L64:
    r64 = r1
    dec_ref r64
    r77 = __mypyc_self__.__mypyc_temp__3
    if is_error(r77) goto L66 (error at cache_close:-1) else goto L65
L65:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    goto L74
L66:
    r78 = __mypyc_self__.__mypyc_temp__3
    if is_error(r78) goto L83 (error at cache_close:-1) else goto L67
L67:
    CPy_RestoreExcInfo(r78)
    dec_ref r78
    r79 = CPy_KeepPropagating()
    if not r79 goto L83 else goto L68 :: bool
L68:
    unreachable
L69:
    r80 = __mypyc_self__.__mypyc_temp__2
    if is_error(r80) goto L97 (error at cache_close:-1) else goto L70
L70:
    r81 = CPyIter_Send(r80, arg)
    dec_ref r80
    dec_ref arg
    if is_error(r81) goto L72 else goto L71
L71:
    r67 = r81
    goto L53
L72:
    r82 = CPy_FetchStopIterationValue()
    if is_error(r82) goto L83 (error at cache_close:159) else goto L73
L73:
    r64 = r82
    dec_ref r64
L74:
    r83 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L75:
    if is_error(stop_iter_ptr) goto L76 else goto L78
L76:
    CPyGen_SetStopIterationValue(r83)
    if not 0 goto L83 else goto L77 :: bool
L77:
    unreachable
L78:
    inc_ref r83
    set_mem stop_iter_ptr, r83 :: builtins.object*
    return 0
L79:
    r85 = r2 == 0
    if r85 goto L98 else goto L80 :: bool
L80:
    r86 = r2 == 1
    if r86 goto L54 else goto L99 :: bool
L81:
    r87 = raise StopIteration
    if not r87 goto L83 (error at cache_close:147) else goto L82 :: bool
L82:
    unreachable
L83:
    r88 = <error> :: object
    return r88
L84:
    dec_ref r27
    goto L83
L85:
    dec_ref r35
    goto L83
L86:
    dec_ref r41
    goto L83
L87:
    dec_ref r45
    goto L34
L88:
    dec_ref r49
    goto L39
L89:
    dec_ref r49
    goto L83
L90:
    dec_ref r52
    goto L83
L91:
    dec_ref r53
    goto L43
L92:
    dec_ref r55
    goto L83
L93:
    xdec_ref r1
    goto L57
L94:
    xdec_ref r1
    goto L56
L95:
    xdec_ref r1
    goto L66
L96:
    dec_ref r67
    goto L66
L97:
    dec_ref arg
    goto L83
L98:
    xdec_ref r1
    goto L1
L99:
    xdec_ref r1
    goto L81

def cache_close__LRUCacheWrapper_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = cache_close__LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def cache_close__LRUCacheWrapper_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = cache_close__LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def cache_close__LRUCacheWrapper_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def cache_close__LRUCacheWrapper_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = cache_close__LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def cache_close__LRUCacheWrapper_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def cache_close__LRUCacheWrapper_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapper_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _LRUCacheWrapper.cache_close(self, wait):
    self :: faster_async_lru._LRUCacheWrapper
    wait :: bool
    r0 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r1, r2, r3 :: bool
    r4 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
L0:
    if is_error(wait) goto L1 else goto L2
L1:
    wait = 0
L2:
    r0 = cache_close__LRUCacheWrapper_gen()
    if is_error(r0) goto L6 (error at cache_close:147) else goto L3
L3:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L7 (error at cache_close:147) else goto L4 :: bool
L4:
    r0.__mypyc_generator_attribute__wait = wait; r3 = is_error
    if not r3 goto L7 (error at cache_close:147) else goto L5 :: bool
L5:
    return r0
L6:
    r4 = <error> :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    return r4
L7:
    dec_ref r0
    goto L6

def _LRUCacheWrapper.cache_info(self):
    self :: faster_async_lru._LRUCacheWrapper
    r0, r1 :: int
    r2 :: union[int, None]
    r3 :: dict
    r4 :: native_int
    r5 :: short_int
    r6 :: dict
    r7 :: str
    r8, r9, r10, r11 :: object
    r12 :: object[4]
    r13 :: object_ptr
    r14 :: object
    r15, r16 :: tuple
L0:
    r0 = self.__hits
    if is_error(r0) goto L8 (error at cache_info:163) else goto L1
L1:
    r1 = self.__misses
    if is_error(r1) goto L9 (error at cache_info:164) else goto L2
L2:
    r2 = self.__maxsize
    if is_error(r2) goto L10 (error at cache_info:165) else goto L3
L3:
    r3 = self.__cache
    if is_error(r3) goto L11 (error at cache_info:166) else goto L4
L4:
    r4 = PyDict_Size(r3)
    dec_ref r3
    r5 = r4 << 1
    r6 = faster_async_lru.globals :: static
    r7 = '_CacheInfo'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L11 (error at cache_info:162) else goto L5
L5:
    r9 = box(int, r0)
    r10 = box(int, r1)
    r11 = box(short_int, r5)
    r12 = [r9, r10, r2, r11]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r8, r13, 4, 0)
    dec_ref r8
    if is_error(r14) goto L12 (error at cache_info:162) else goto L6
L6:
    dec_ref r9
    dec_ref r10
    dec_ref r2
    dec_ref r11
    r15 = cast(tuple, r14)
    if is_error(r15) goto L8 (error at cache_info:162) else goto L7
L7:
    return r15
L8:
    r16 = <error> :: tuple
    return r16
L9:
    dec_ref r0 :: int
    goto L8
L10:
    dec_ref r0 :: int
    dec_ref r1 :: int
    goto L8
L11:
    dec_ref r0 :: int
    dec_ref r1 :: int
    dec_ref r2
    goto L8
L12:
    dec_ref r2
    dec_ref r9
    dec_ref r10
    dec_ref r11
    goto L8

def _LRUCacheWrapper.cache_parameters(self):
    self :: faster_async_lru._LRUCacheWrapper
    r0 :: union[int, None]
    r1 :: bool
    r2 :: set
    r3 :: ptr
    r4 :: native_int
    r5 :: short_int
    r6 :: bool
    r7 :: dict
    r8 :: str
    r9, r10, r11, r12 :: object
    r13 :: object[4]
    r14 :: object_ptr
    r15, r16 :: object
    r17, r18 :: dict
L0:
    r0 = self.__maxsize
    if is_error(r0) goto L8 (error at cache_parameters:171) else goto L1
L1:
    r1 = self.__typed
    if is_error(r1) goto L9 (error at cache_parameters:172) else goto L2
L2:
    r2 = self.__tasks
    if is_error(r2) goto L9 (error at cache_parameters:173) else goto L3
L3:
    r3 = get_element_ptr r2 used :: PySetObject
    r4 = load_mem r3 :: native_int*
    dec_ref r2
    r5 = r4 << 1
    r6 = self.__closed
    if is_error(r6) goto L9 (error at cache_parameters:174) else goto L4
L4:
    r7 = faster_async_lru.globals :: static
    r8 = '_CacheParameters'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L9 (error at cache_parameters:170) else goto L5
L5:
    r10 = box(bool, r1)
    r11 = box(short_int, r5)
    r12 = box(bool, r6)
    r13 = [r0, r10, r11, r12]
    r14 = load_address r13
    r15 = ('maxsize', 'typed', 'tasks', 'closed')
    r16 = PyObject_Vectorcall(r9, r14, 0, r15)
    dec_ref r9
    if is_error(r16) goto L10 (error at cache_parameters:170) else goto L6
L6:
    dec_ref r0
    dec_ref r11
    r17 = cast(dict, r16)
    if is_error(r17) goto L8 (error at cache_parameters:170) else goto L7
L7:
    return r17
L8:
    r18 = <error> :: dict
    return r18
L9:
    dec_ref r0
    goto L8
L10:
    dec_ref r0
    dec_ref r11
    goto L8

def _LRUCacheWrapper._cache_hit(self, key):
    self :: faster_async_lru._LRUCacheWrapper
    key :: object
    r0, r1 :: int
    r2 :: bool
    r3 :: dict
    r4 :: str
    r5 :: object[2]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = borrow self.__hits
    if is_error(r0) goto L5 (error at _cache_hit:178) else goto L1
L1:
    r1 = CPyTagged_Add(r0, 2)
    self.__hits = r1; r2 = is_error
    if not r2 goto L5 (error at _cache_hit:178) else goto L2 :: bool
L2:
    r3 = self.__cache
    if is_error(r3) goto L5 (error at _cache_hit:179) else goto L3
L3:
    r4 = 'move_to_end'
    r5 = [r3, key]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775810, 0)
    if is_error(r7) goto L6 (error at _cache_hit:179) else goto L7
L4:
    dec_ref r3
    return 1
L5:
    r8 = <error> :: None
    return r8
L6:
    dec_ref r3
    goto L5
L7:
    dec_ref r7
    goto L4

def _LRUCacheWrapper._cache_miss(self, key):
    self :: faster_async_lru._LRUCacheWrapper
    key :: object
    r0, r1 :: int
    r2 :: bool
    r3 :: None
L0:
    r0 = borrow self.__misses
    if is_error(r0) goto L3 (error at _cache_miss:182) else goto L1
L1:
    r1 = CPyTagged_Add(r0, 2)
    self.__misses = r1; r2 = is_error
    if not r2 goto L3 (error at _cache_miss:182) else goto L2 :: bool
L2:
    return 1
L3:
    r3 = <error> :: None
    return r3

def _LRUCacheWrapper._task_done_callback(self, fut, key, task):
    self :: faster_async_lru._LRUCacheWrapper
    fut, key, task :: object
    r0 :: set
    r1 :: i32
    r2 :: bit
    r3 :: dict
    r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: bool
    r9 :: str
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[3]
    r16 :: object_ptr
    r17 :: object
    r18 :: str
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    exc :: union[object, None]
    r22 :: object
    r23 :: bit
    r24 :: str
    r25 :: object[2]
    r26 :: object_ptr
    r27 :: object
    r28 :: str
    r29 :: object
    r30 :: object[3]
    r31 :: object_ptr
    r32, r33 :: object
    r34 :: union[faster_async_lru._CacheItem, None]
    r35 :: union[float, None]
    r36 :: object
    r37 :: bit
    r38 :: object
    r39 :: bit
    r40 :: object
    r41 :: bool
    r42 :: object
    r43 :: float
    r44 :: bit
    r45 :: str
    r46, r47 :: object
    r48 :: str
    r49, r50 :: object
    r51 :: object[5]
    r52 :: object_ptr
    r53 :: object
    r54 :: faster_async_lru._CacheItem
    r55 :: bool
    r56 :: str
    r57 :: object[1]
    r58 :: object_ptr
    r59 :: object
    r60 :: str
    r61 :: object[2]
    r62 :: object_ptr
    r63 :: object
    r64 :: None
L0:
    r0 = self.__tasks
    if is_error(r0) goto L33 (error at _task_done_callback:187) else goto L1
L1:
    r1 = PySet_Discard(r0, task)
    dec_ref r0
    r2 = r1 >= 0 :: signed
    if not r2 goto L33 (error at _task_done_callback:187) else goto L2 :: bool
L2:
    r3 = self.__cache
    if is_error(r3) goto L33 (error at _task_done_callback:189) else goto L3
L3:
    r4 = 'cancelled'
    r5 = [task]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L34 (error at _task_done_callback:191) else goto L4
L4:
    r8 = unbox(bool, r7)
    dec_ref r7
    if is_error(r8) goto L34 (error at _task_done_callback:191) else goto L5
L5:
    if r8 goto L6 else goto L9 :: bool
L6:
    r9 = 'cancel'
    r10 = [fut]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775809, 0)
    if is_error(r12) goto L34 (error at _task_done_callback:192) else goto L35
L7:
    r13 = 'pop'
    r14 = box(None, 1)
    r15 = [r3, key, r14]
    r16 = load_address r15
    r17 = PyObject_VectorcallMethod(r13, r16, 9223372036854775811, 0)
    if is_error(r17) goto L34 (error at _task_done_callback:193) else goto L36
L8:
    dec_ref r3
    return 1
L9:
    r18 = 'exception'
    r19 = [task]
    r20 = load_address r19
    r21 = PyObject_VectorcallMethod(r18, r20, 9223372036854775809, 0)
    if is_error(r21) goto L34 (error at _task_done_callback:196) else goto L10
L10:
    exc = r21
    r22 = load_address _Py_NoneStruct
    r23 = exc != r22
    if r23 goto L11 else goto L37 :: bool
L11:
    r24 = 'set_exception'
    r25 = [fut, exc]
    r26 = load_address r25
    r27 = PyObject_VectorcallMethod(r24, r26, 9223372036854775810, 0)
    if is_error(r27) goto L38 (error at _task_done_callback:198) else goto L39
L12:
    dec_ref exc
    r28 = 'pop'
    r29 = box(None, 1)
    r30 = [r3, key, r29]
    r31 = load_address r30
    r32 = PyObject_VectorcallMethod(r28, r31, 9223372036854775811, 0)
    if is_error(r32) goto L34 (error at _task_done_callback:199) else goto L40
L13:
    dec_ref r3
    return 1
L14:
    r33 = CPyDict_GetWithNone(r3, key)
    if is_error(r33) goto L34 (error at _task_done_callback:202) else goto L15
L15:
    r34 = cast(union[faster_async_lru._CacheItem, None], r33)
    if is_error(r34) goto L34 (error at _task_done_callback:202) else goto L16
L16:
    r35 = self.__ttl
    if is_error(r35) goto L41 (error at _task_done_callback:203) else goto L17
L17:
    r36 = load_address _Py_NoneStruct
    r37 = r35 != r36
    if r37 goto L18 else goto L42 :: bool
L18:
    r38 = load_address _Py_NoneStruct
    r39 = r34 != r38
    if r39 goto L19 else goto L42 :: bool
L19:
    r40 = faster_async_lru.get_running_loop :: static
    if is_error(r40) goto L43 else goto L22
L20:
    r41 = raise NameError('value for final name "get_running_loop" was not set')
    if not r41 goto L33 (error at _task_done_callback:205) else goto L21 :: bool
L21:
    unreachable
L22:
    r42 = PyObject_Vectorcall(r40, 0, 0, 0)
    if is_error(r42) goto L44 (error at _task_done_callback:205) else goto L23
L23:
    r43 = unbox(float, r35)
    dec_ref r35
    r44 = r43 == -113.0
    if r44 goto L25 else goto L24 :: bool
L24:
    r45 = 'pop'
    r46 = CPyObject_GetAttr(r3, r45)
    dec_ref r3
    if is_error(r46) goto L45 (error at _task_done_callback:207) else goto L26
L25:
    r47 = PyErr_Occurred()
    if not is_error(r47) goto L46 (error at _task_done_callback:207) else goto L24
L26:
    r48 = 'call_later'
    r49 = box(float, r43)
    r50 = box(None, 1)
    r51 = [r42, r49, r46, key, r50]
    r52 = load_address r51
    r53 = PyObject_VectorcallMethod(r48, r52, 9223372036854775813, 0)
    if is_error(r53) goto L47 (error at _task_done_callback:206) else goto L27
L27:
    dec_ref r42
    dec_ref r49
    dec_ref r46
    r54 = borrow cast(faster_async_lru._CacheItem, r34)
    if is_error(r54) goto L48 (error at _task_done_callback:206) else goto L28
L28:
    r54.later_call = r53; r55 = is_error
    if not r55 goto L49 (error at _task_done_callback:206) else goto L29 :: bool
L29:
    dec_ref r34
L30:
    r56 = 'result'
    r57 = [task]
    r58 = load_address r57
    r59 = PyObject_VectorcallMethod(r56, r58, 9223372036854775809, 0)
    if is_error(r59) goto L33 (error at _task_done_callback:210) else goto L31
L31:
    r60 = 'set_result'
    r61 = [fut, r59]
    r62 = load_address r61
    r63 = PyObject_VectorcallMethod(r60, r62, 9223372036854775810, 0)
    if is_error(r63) goto L50 (error at _task_done_callback:210) else goto L51
L32:
    dec_ref r59
    return 1
L33:
    r64 = <error> :: None
    return r64
L34:
    dec_ref r3
    goto L33
L35:
    dec_ref r12
    goto L7
L36:
    dec_ref r17
    goto L8
L37:
    dec_ref exc
    goto L14
L38:
    dec_ref r3
    dec_ref exc
    goto L33
L39:
    dec_ref r27
    goto L12
L40:
    dec_ref r32
    goto L13
L41:
    dec_ref r3
    dec_ref r34
    goto L33
L42:
    dec_ref r3
    dec_ref r34
    dec_ref r35
    goto L30
L43:
    dec_ref r3
    dec_ref r34
    dec_ref r35
    goto L20
L44:
    dec_ref r3
    dec_ref r34
    dec_ref r35
    goto L33
L45:
    dec_ref r34
    dec_ref r42
    goto L33
L46:
    dec_ref r3
    dec_ref r34
    dec_ref r42
    goto L33
L47:
    dec_ref r34
    dec_ref r42
    dec_ref r46
    dec_ref r49
    goto L33
L48:
    dec_ref r34
    dec_ref r53
    goto L33
L49:
    dec_ref r34
    goto L33
L50:
    dec_ref r59
    goto L33
L51:
    dec_ref r63
    goto L32

def __call____LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: object
    r6 :: bit
    r7 :: faster_async_lru._LRUCacheWrapper
    r8 :: bool
    r9 :: str
    r10 :: faster_async_lru._LRUCacheWrapper
    r11, r12 :: str
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18, r19 :: object
    r20 :: bool
    r21 :: object
    r22 :: bool
    r23 :: tuple
    r24 :: dict
    r25 :: faster_async_lru._LRUCacheWrapper
    r26 :: bool
    r27 :: union[str, int, faster_async_lru._HashedSeq]
    r28 :: bool
    r29 :: faster_async_lru._LRUCacheWrapper
    r30 :: dict
    r31 :: bool
    r32 :: dict
    r33 :: union[str, int, faster_async_lru._HashedSeq]
    r34 :: object
    r35 :: union[faster_async_lru._CacheItem, None]
    r36 :: bool
    r37 :: union[faster_async_lru._CacheItem, None]
    r38 :: object
    r39 :: bit
    r40 :: faster_async_lru._LRUCacheWrapper
    r41 :: union[str, int, faster_async_lru._HashedSeq]
    r42 :: None
    r43 :: union[faster_async_lru._CacheItem, None]
    r44 :: faster_async_lru._CacheItem
    r45 :: object
    r46 :: bool
    r47 :: object
    r48 :: str
    r49 :: object[1]
    r50 :: object_ptr
    r51 :: object
    r52 :: bool
    r53, r54 :: object
    r55 :: bool
    r56 :: object[1]
    r57 :: object_ptr
    r58, r59 :: object
    r60 :: bool
    r61, r62, r63, r64, r65 :: object
    r66 :: bool
    r67 :: object
    r68 :: bool
    r69 :: object
    r70 :: bit
    r71 :: tuple[object, object, object]
    r72 :: bool
    r73 :: object_ptr
    r74 :: object
    r75 :: bool
    r76, r77, r78 :: tuple[object, object, object]
    r79 :: bit
    r80, r81, r82 :: object
    r83 :: bool
    r84 :: object
    r85 :: str
    r86 :: object[1]
    r87 :: object_ptr
    r88 :: object
    r89 :: bool
    r90 :: object
    r91 :: str
    r92 :: object[1]
    r93 :: object_ptr
    r94 :: object
    r95 :: bool
    r96 :: faster_async_lru._LRUCacheWrapper
    r97 :: tuple
    r98 :: dict
    r99 :: str
    r100 :: object
    r101 :: dict
    r102 :: object
    r103 :: bool
    r104, r105 :: object
    r106 :: str
    r107 :: object[2]
    r108 :: object_ptr
    r109 :: object
    r110 :: bool
    r111 :: faster_async_lru._LRUCacheWrapper
    r112 :: set
    r113 :: object
    r114 :: i32
    r115 :: bit
    r116 :: object
    r117 :: faster_async_lru._LRUCacheWrapper
    r118 :: str
    r119, r120 :: object
    r121 :: union[str, int, faster_async_lru._HashedSeq]
    r122 :: object
    r123 :: bool
    r124 :: object[3]
    r125 :: object_ptr
    r126 :: object
    r127 :: str
    r128 :: object[2]
    r129 :: object_ptr
    r130, r131, r132 :: object
    r133 :: tuple
    r134 :: dict
    r135 :: faster_async_lru._CacheItem
    r136 :: dict
    r137 :: union[str, int, faster_async_lru._HashedSeq]
    r138 :: i32
    r139 :: bit
    r140 :: faster_async_lru._LRUCacheWrapper
    r141 :: union[int, None]
    r142 :: bool
    r143 :: union[int, None]
    r144 :: object
    r145 :: bit
    r146 :: dict
    r147 :: native_int
    r148 :: short_int
    r149 :: union[int, None]
    r150 :: int
    r151 :: native_int
    r152 :: bit
    r153 :: native_int
    r154, r155 :: bit
    r156 :: bool
    r157 :: bit
    r158 :: dict
    r159 :: str
    r160 :: object
    r161 :: object[2]
    r162 :: object_ptr
    r163, r164 :: object
    r165 :: tuple[object, faster_async_lru._CacheItem]
    r166 :: object
    r167 :: faster_async_lru._CacheItem
    r168 :: object
    r169 :: bool
    r170 :: faster_async_lru._CacheItem
    r171 :: bool
    r172 :: union[faster_async_lru._CacheItem, None]
    r173 :: faster_async_lru._CacheItem
    r174 :: None
    r175 :: faster_async_lru._LRUCacheWrapper
    r176 :: union[str, int, faster_async_lru._HashedSeq]
    r177 :: None
    r178, r179 :: object
    r180 :: bool
    r181 :: object[1]
    r182 :: object_ptr
    r183, r184 :: object
    r185 :: bool
    r186, r187, r188, r189, r190 :: object
    r191 :: bool
    r192 :: object
    r193 :: bool
    r194 :: object
    r195 :: bit
    r196 :: tuple[object, object, object]
    r197 :: bool
    r198 :: object_ptr
    r199 :: object
    r200 :: bool
    r201, r202, r203 :: tuple[object, object, object]
    r204 :: bit
    r205, r206, r207 :: object
    r208 :: bool
    r209, r210, r211 :: bit
    r212 :: bool
    r213 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_next_label__
    goto L188
L1:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L193 (error at __call__:212) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r7) goto L193 (error at __call__:213) else goto L5
L5:
    r8 = r7.__closed
    dec_ref r7
    if is_error(r8) goto L193 (error at __call__:213) else goto L6
L6:
    if r8 goto L7 else goto L14 :: bool
L7:
    r9 = 'alru_cache is closed for '
    r10 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r10) goto L193 (error at __call__:214) else goto L8
L8:
    r11 = PyObject_Str(r10)
    dec_ref r10
    if is_error(r11) goto L193 (error at __call__:214) else goto L9
L9:
    r12 = CPyStr_Build(2, r9, r11)
    dec_ref r11
    if is_error(r12) goto L193 (error at __call__:214) else goto L10
L10:
    r13 = builtins :: module
    r14 = 'RuntimeError'
    r15 = CPyObject_GetAttr(r13, r14)
    if is_error(r15) goto L194 (error at __call__:214) else goto L11
L11:
    r16 = [r12]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L194 (error at __call__:214) else goto L12
L12:
    dec_ref r12
    CPy_Raise(r18)
    dec_ref r18
    if not 0 goto L193 (error at __call__:214) else goto L13 :: bool
L13:
    unreachable
L14:
    r19 = faster_async_lru.get_running_loop :: static
    if is_error(r19) goto L15 else goto L17
L15:
    r20 = raise NameError('value for final name "get_running_loop" was not set')
    if not r20 goto L193 (error at __call__:216) else goto L16 :: bool
L16:
    unreachable
L17:
    r21 = PyObject_Vectorcall(r19, 0, 0, 0)
    if is_error(r21) goto L193 (error at __call__:216) else goto L18
L18:
    __mypyc_self__.__mypyc_generator_attribute__loop = r21; r22 = is_error
    if not r22 goto L193 (error at __call__:216) else goto L19 :: bool
L19:
    r23 = __mypyc_self__.__mypyc_generator_attribute__fn_args
    if is_error(r23) goto L193 (error at __call__:218) else goto L20
L20:
    r24 = __mypyc_self__.__mypyc_generator_attribute__fn_kwargs
    if is_error(r24) goto L195 (error at __call__:218) else goto L21
L21:
    r25 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r25) goto L196 (error at __call__:218) else goto L22
L22:
    r26 = r25.__typed
    dec_ref r25
    if is_error(r26) goto L196 (error at __call__:218) else goto L23
L23:
    r27 = _make_key(r23, r24, r26)
    dec_ref r23
    dec_ref r24
    if is_error(r27) goto L193 (error at __call__:218) else goto L24
L24:
    __mypyc_self__.__mypyc_generator_attribute__key = r27; r28 = is_error
    if not r28 goto L193 (error at __call__:218) else goto L25 :: bool
L25:
    r29 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r29) goto L193 (error at __call__:220) else goto L26
L26:
    r30 = r29.__cache
    dec_ref r29
    if is_error(r30) goto L193 (error at __call__:220) else goto L27
L27:
    __mypyc_self__.__mypyc_generator_attribute__cache = r30; r31 = is_error
    if not r31 goto L193 (error at __call__:220) else goto L28 :: bool
L28:
    r32 = __mypyc_self__.__mypyc_generator_attribute__cache
    if is_error(r32) goto L193 (error at __call__:222) else goto L29
L29:
    r33 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r33) goto L197 (error at __call__:222) else goto L30
L30:
    r34 = CPyDict_GetWithNone(r32, r33)
    dec_ref r32
    dec_ref r33
    if is_error(r34) goto L193 (error at __call__:222) else goto L31
L31:
    r35 = cast(union[faster_async_lru._CacheItem, None], r34)
    if is_error(r35) goto L193 (error at __call__:222) else goto L32
L32:
    __mypyc_self__.__mypyc_generator_attribute__cache_item = r35; r36 = is_error
    if not r36 goto L193 (error at __call__:222) else goto L33 :: bool
L33:
    r37 = __mypyc_self__.__mypyc_generator_attribute__cache_item
    if is_error(r37) goto L193 (error at __call__:224) else goto L34
L34:
    r38 = load_address _Py_NoneStruct
    r39 = r37 != r38
    dec_ref r37
    if r39 goto L35 else goto L91 :: bool
L35:
    r40 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r40) goto L193 (error at __call__:225) else goto L36
L36:
    r41 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r41) goto L198 (error at __call__:225) else goto L37
L37:
    r42 = r40._cache_hit(r41)
    dec_ref r41
    dec_ref r40
    if is_error(r42) goto L193 (error at __call__:225) else goto L38
L38:
    r43 = __mypyc_self__.__mypyc_generator_attribute__cache_item
    if is_error(r43) goto L193 (error at __call__:227) else goto L39
L39:
    r44 = borrow cast(faster_async_lru._CacheItem, r43)
    if is_error(r44) goto L199 (error at __call__:227) else goto L40
L40:
    r45 = r44.fut
    if is_error(r45) goto L199 (error at __call__:227) else goto L41
L41:
    dec_ref r43
    __mypyc_self__.__mypyc_generator_attribute__fut = r45; r46 = is_error
    if not r46 goto L193 (error at __call__:227) else goto L42 :: bool
L42:
    r47 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r47) goto L193 (error at __call__:228) else goto L43
L43:
    r48 = 'done'
    r49 = [r47]
    r50 = load_address r49
    r51 = PyObject_VectorcallMethod(r48, r50, 9223372036854775809, 0)
    if is_error(r51) goto L200 (error at __call__:228) else goto L44
L44:
    dec_ref r47
    r52 = unbox(bool, r51)
    dec_ref r51
    if is_error(r52) goto L193 (error at __call__:228) else goto L45
L45:
    if r52 goto L84 else goto L46 :: bool
L46:
    r53 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r53) goto L193 (error at __call__:229) else goto L47
L47:
    r54 = faster_async_lru.shield :: static
    if is_error(r54) goto L201 else goto L50
L48:
    r55 = raise NameError('value for final name "shield" was not set')
    if not r55 goto L193 (error at __call__:229) else goto L49 :: bool
L49:
    unreachable
L50:
    r56 = [r53]
    r57 = load_address r56
    r58 = PyObject_Vectorcall(r54, r57, 1, 0)
    if is_error(r58) goto L202 (error at __call__:229) else goto L51
L51:
    dec_ref r53
    r59 = CPy_GetCoro(r58)
    dec_ref r58
    if is_error(r59) goto L193 (error at __call__:229) else goto L52
L52:
    __mypyc_self__.__mypyc_temp__4 = r59; r60 = is_error
    if not r60 goto L193 (error at __call__:-1) else goto L53 :: bool
L53:
    r61 = __mypyc_self__.__mypyc_temp__4
    if is_error(r61) goto L193 (error at __call__:-1) else goto L54
L54:
    r62 = CPyIter_Next(r61)
    dec_ref r61
    if is_error(r62) goto L55 else goto L57
L55:
    r63 = CPy_FetchStopIterationValue()
    if is_error(r63) goto L193 (error at __call__:229) else goto L56
L56:
    r64 = r63
    r65 = <error> :: object
    __mypyc_self__.__mypyc_temp__4 = r65; r66 = is_error
    if not r66 goto L203 (error at __call__:229) else goto L79 :: bool
L57:
    r67 = r62
L58:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r67
L59:
    r69 = load_address _Py_NoneStruct
    r70 = type != r69
    if r70 goto L60 else goto L204 :: bool
L60:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L63 (error at __call__:229) else goto L205 :: bool
L61:
    unreachable
L62:
    inc_ref arg
    goto L74
L63:
    r71 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__5 = r71; r72 = is_error
    if not r72 goto L206 (error at __call__:-1) else goto L64 :: bool
L64:
    r73 = load_address r1
    r74 = __mypyc_self__.__mypyc_temp__4
    if is_error(r74) goto L206 (error at __call__:-1) else goto L65
L65:
    r75 = CPy_YieldFromErrorHandle(r74, r73)
    dec_ref r74
    if is_error(r75) goto L206 (error at __call__:229) else goto L66
L66:
    if r75 goto L69 else goto L67 :: bool
L67:
    r67 = r1
    r76 = __mypyc_self__.__mypyc_temp__5
    if is_error(r76) goto L207 (error at __call__:-1) else goto L68
L68:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    goto L58
L69:
    r64 = r1
    r77 = __mypyc_self__.__mypyc_temp__5
    if is_error(r77) goto L208 (error at __call__:-1) else goto L70
L70:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    goto L79
L71:
    r78 = __mypyc_self__.__mypyc_temp__5
    if is_error(r78) goto L193 (error at __call__:-1) else goto L72
L72:
    CPy_RestoreExcInfo(r78)
    dec_ref r78
    r79 = CPy_KeepPropagating()
    if not r79 goto L193 else goto L73 :: bool
L73:
    unreachable
L74:
    r80 = __mypyc_self__.__mypyc_temp__4
    if is_error(r80) goto L209 (error at __call__:-1) else goto L75
L75:
    r81 = CPyIter_Send(r80, arg)
    dec_ref r80
    dec_ref arg
    if is_error(r81) goto L77 else goto L76
L76:
    r67 = r81
    goto L58
L77:
    r82 = CPy_FetchStopIterationValue()
    if is_error(r82) goto L193 (error at __call__:229) else goto L78
L78:
    r64 = r82
L79:
    __mypyc_self__.__mypyc_next_label__ = -1
L80:
    if is_error(stop_iter_ptr) goto L81 else goto L83
L81:
    CPyGen_SetStopIterationValue(r64)
    dec_ref r64
    if not 0 goto L193 else goto L82 :: bool
L82:
    unreachable
L83:
    set_mem stop_iter_ptr, r64 :: builtins.object*
    return 0
L84:
    r84 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r84) goto L193 (error at __call__:231) else goto L85
L85:
    r85 = 'result'
    r86 = [r84]
    r87 = load_address r86
    r88 = PyObject_VectorcallMethod(r85, r87, 9223372036854775809, 0)
    if is_error(r88) goto L210 (error at __call__:231) else goto L86
L86:
    dec_ref r84
    __mypyc_self__.__mypyc_next_label__ = -1
L87:
    if is_error(stop_iter_ptr) goto L88 else goto L90
L88:
    CPyGen_SetStopIterationValue(r88)
    dec_ref r88
    if not 0 goto L193 else goto L89 :: bool
L89:
    unreachable
L90:
    set_mem stop_iter_ptr, r88 :: builtins.object*
    return 0
L91:
    r90 = __mypyc_self__.__mypyc_generator_attribute__loop
    if is_error(r90) goto L193 (error at __call__:233) else goto L92
L92:
    r91 = 'create_future'
    r92 = [r90]
    r93 = load_address r92
    r94 = PyObject_VectorcallMethod(r91, r93, 9223372036854775809, 0)
    if is_error(r94) goto L211 (error at __call__:233) else goto L93
L93:
    dec_ref r90
    __mypyc_self__.__mypyc_generator_attribute__fut = r94; r95 = is_error
    if not r95 goto L193 (error at __call__:233) else goto L94 :: bool
L94:
    r96 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r96) goto L193 (error at __call__:234) else goto L95
L95:
    r97 = __mypyc_self__.__mypyc_generator_attribute__fn_args
    if is_error(r97) goto L212 (error at __call__:234) else goto L96
L96:
    r98 = __mypyc_self__.__mypyc_generator_attribute__fn_kwargs
    if is_error(r98) goto L213 (error at __call__:234) else goto L97
L97:
    r99 = '__wrapped__'
    r100 = CPyObject_GetAttr(r96, r99)
    dec_ref r96
    if is_error(r100) goto L214 (error at __call__:234) else goto L98
L98:
    r101 = PyDict_Copy(r98)
    dec_ref r98
    if is_error(r101) goto L215 (error at __call__:234) else goto L99
L99:
    r102 = PyObject_Call(r100, r97, r101)
    dec_ref r100
    dec_ref r97
    dec_ref r101
    if is_error(r102) goto L193 (error at __call__:234) else goto L100
L100:
    __mypyc_self__.__mypyc_generator_attribute__coro = r102; r103 = is_error
    if not r103 goto L193 (error at __call__:234) else goto L101 :: bool
L101:
    r104 = __mypyc_self__.__mypyc_generator_attribute__loop
    if is_error(r104) goto L193 (error at __call__:235) else goto L102
L102:
    r105 = __mypyc_self__.__mypyc_generator_attribute__coro
    if is_error(r105) goto L216 (error at __call__:235) else goto L103
L103:
    r106 = 'create_task'
    r107 = [r104, r105]
    r108 = load_address r107
    r109 = PyObject_VectorcallMethod(r106, r108, 9223372036854775810, 0)
    if is_error(r109) goto L217 (error at __call__:235) else goto L104
L104:
    dec_ref r104
    dec_ref r105
    __mypyc_self__.__mypyc_generator_attribute__task = r109; r110 = is_error
    if not r110 goto L193 (error at __call__:235) else goto L105 :: bool
L105:
    r111 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r111) goto L193 (error at __call__:236) else goto L106
L106:
    r112 = r111.__tasks
    dec_ref r111
    if is_error(r112) goto L193 (error at __call__:236) else goto L107
L107:
    r113 = __mypyc_self__.__mypyc_generator_attribute__task
    if is_error(r113) goto L218 (error at __call__:236) else goto L108
L108:
    r114 = PySet_Add(r112, r113)
    dec_ref r112
    dec_ref r113
    r115 = r114 >= 0 :: signed
    if not r115 goto L193 (error at __call__:236) else goto L109 :: bool
L109:
    r116 = __mypyc_self__.__mypyc_generator_attribute__task
    if is_error(r116) goto L193 (error at __call__:237) else goto L110
L110:
    r117 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r117) goto L219 (error at __call__:237) else goto L111
L111:
    r118 = '_task_done_callback'
    r119 = CPyObject_GetAttr(r117, r118)
    dec_ref r117
    if is_error(r119) goto L219 (error at __call__:237) else goto L112
L112:
    r120 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r120) goto L220 (error at __call__:237) else goto L113
L113:
    r121 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r121) goto L221 (error at __call__:237) else goto L114
L114:
    r122 = faster_async_lru.partial :: static
    if is_error(r122) goto L222 else goto L117
L115:
    r123 = raise NameError('value for final name "partial" was not set')
    if not r123 goto L193 (error at __call__:237) else goto L116 :: bool
L116:
    unreachable
L117:
    r124 = [r119, r120, r121]
    r125 = load_address r124
    r126 = PyObject_Vectorcall(r122, r125, 3, 0)
    if is_error(r126) goto L223 (error at __call__:237) else goto L118
L118:
    dec_ref r119
    dec_ref r120
    dec_ref r121
    r127 = 'add_done_callback'
    r128 = [r116, r126]
    r129 = load_address r128
    r130 = PyObject_VectorcallMethod(r127, r129, 9223372036854775810, 0)
    if is_error(r130) goto L224 (error at __call__:237) else goto L225
L119:
    dec_ref r116
    dec_ref r126
    r131 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r131) goto L193 (error at __call__:239) else goto L120
L120:
    r132 = box(None, 1)
    r133 = PyTuple_Pack(2, r131, r132)
    dec_ref r131
    if is_error(r133) goto L193 (error at __call__:239) else goto L121
L121:
    r134 = PyDict_New()
    if is_error(r134) goto L226 (error at __call__:239) else goto L122
L122:
    r135 = _CacheItem(r133, r134)
    dec_ref r133
    dec_ref r134
    if is_error(r135) goto L193 (error at __call__:239) else goto L123
L123:
    r136 = __mypyc_self__.__mypyc_generator_attribute__cache
    if is_error(r136) goto L227 (error at __call__:239) else goto L124
L124:
    r137 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r137) goto L228 (error at __call__:239) else goto L125
L125:
    r138 = CPyDict_SetItem(r136, r137, r135)
    dec_ref r136
    dec_ref r137
    dec_ref r135
    r139 = r138 >= 0 :: signed
    if not r139 goto L193 (error at __call__:239) else goto L126 :: bool
L126:
    r140 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r140) goto L193 (error at __call__:241) else goto L127
L127:
    r141 = r140.__maxsize
    dec_ref r140
    if is_error(r141) goto L193 (error at __call__:241) else goto L128
L128:
    __mypyc_self__.__mypyc_generator_attribute__maxsize = r141; r142 = is_error
    if not r142 goto L193 (error at __call__:241) else goto L129 :: bool
L129:
    r143 = __mypyc_self__.__mypyc_generator_attribute__maxsize
    if is_error(r143) goto L193 (error at __call__:242) else goto L130
L130:
    r144 = load_address _Py_NoneStruct
    r145 = r143 != r144
    dec_ref r143
    if r145 goto L131 else goto L147 :: bool
L131:
    r146 = __mypyc_self__.__mypyc_generator_attribute__cache
    if is_error(r146) goto L193 (error at __call__:242) else goto L132
L132:
    r147 = PyDict_Size(r146)
    dec_ref r146
    r148 = r147 << 1
    r149 = __mypyc_self__.__mypyc_generator_attribute__maxsize
    if is_error(r149) goto L193 (error at __call__:242) else goto L133
L133:
    r150 = unbox(int, r149)
    dec_ref r149
    if is_error(r150) goto L193 (error at __call__:242) else goto L134
L134:
    r151 = r148 & 1
    r152 = r151 != 0
    if r152 goto L136 else goto L135 :: bool
L135:
    r153 = r150 & 1
    r154 = r153 != 0
    if r154 goto L136 else goto L137 :: bool
L136:
    r155 = CPyTagged_IsLt_(r150, r148)
    r156 = r155
    goto L138
L137:
    r157 = r148 > r150 :: signed
    r156 = r157
L138:
    dec_ref r150 :: int
    if r156 goto L139 else goto L147 :: bool
L139:
    r158 = __mypyc_self__.__mypyc_generator_attribute__cache
    if is_error(r158) goto L193 (error at __call__:243) else goto L140
L140:
    r159 = 'popitem'
    r160 = box(bool, 0)
    r161 = [r158, r160]
    r162 = load_address r161
    r163 = ('last',)
    r164 = PyObject_VectorcallMethod(r159, r162, 9223372036854775809, r163)
    if is_error(r164) goto L229 (error at __call__:243) else goto L141
L141:
    dec_ref r158
    r165 = unbox(tuple[object, faster_async_lru._CacheItem], r164)
    dec_ref r164
    if is_error(r165) goto L193 (error at __call__:243) else goto L142
L142:
    r166 = borrow r165[0]
    r167 = borrow r165[1]
    r168 = unborrow r166
    __mypyc_self__.__mypyc_generator_attribute__dropped_key = r168; r169 = is_error
    if not r169 goto L193 (error at __call__:243) else goto L143 :: bool
L143:
    r170 = unborrow r167
    __mypyc_self__.__mypyc_generator_attribute__cache_item = r170; r171 = is_error
    if not r171 goto L193 (error at __call__:243) else goto L144 :: bool
L144:
    r172 = __mypyc_self__.__mypyc_generator_attribute__cache_item
    if is_error(r172) goto L193 (error at __call__:244) else goto L145
L145:
    r173 = cast(faster_async_lru._CacheItem, r172)
    if is_error(r173) goto L193 (error at __call__:244) else goto L146
L146:
    r174 = r173.cancel()
    dec_ref r173
    if is_error(r174) goto L193 (error at __call__:244) else goto L147
L147:
    r175 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r175) goto L193 (error at __call__:246) else goto L148
L148:
    r176 = __mypyc_self__.__mypyc_generator_attribute__key
    if is_error(r176) goto L230 (error at __call__:246) else goto L149
L149:
    r177 = r175._cache_miss(r176)
    dec_ref r176
    dec_ref r175
    if is_error(r177) goto L193 (error at __call__:246) else goto L150
L150:
    r178 = __mypyc_self__.__mypyc_generator_attribute__fut
    if is_error(r178) goto L193 (error at __call__:247) else goto L151
L151:
    r179 = faster_async_lru.shield :: static
    if is_error(r179) goto L231 else goto L154
L152:
    r180 = raise NameError('value for final name "shield" was not set')
    if not r180 goto L193 (error at __call__:247) else goto L153 :: bool
L153:
    unreachable
L154:
    r181 = [r178]
    r182 = load_address r181
    r183 = PyObject_Vectorcall(r179, r182, 1, 0)
    if is_error(r183) goto L232 (error at __call__:247) else goto L155
L155:
    dec_ref r178
    r184 = CPy_GetCoro(r183)
    dec_ref r183
    if is_error(r184) goto L193 (error at __call__:247) else goto L156
L156:
    __mypyc_self__.__mypyc_temp__6 = r184; r185 = is_error
    if not r185 goto L193 (error at __call__:-1) else goto L157 :: bool
L157:
    r186 = __mypyc_self__.__mypyc_temp__6
    if is_error(r186) goto L193 (error at __call__:-1) else goto L158
L158:
    r187 = CPyIter_Next(r186)
    dec_ref r186
    if is_error(r187) goto L159 else goto L161
L159:
    r188 = CPy_FetchStopIterationValue()
    if is_error(r188) goto L193 (error at __call__:247) else goto L160
L160:
    r189 = r188
    r190 = <error> :: object
    __mypyc_self__.__mypyc_temp__6 = r190; r191 = is_error
    if not r191 goto L233 (error at __call__:247) else goto L183 :: bool
L161:
    r192 = r187
L162:
    __mypyc_self__.__mypyc_next_label__ = 2
    return r192
L163:
    r194 = load_address _Py_NoneStruct
    r195 = type != r194
    if r195 goto L164 else goto L234 :: bool
L164:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L167 (error at __call__:247) else goto L235 :: bool
L165:
    unreachable
L166:
    inc_ref arg
    goto L178
L167:
    r196 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__7 = r196; r197 = is_error
    if not r197 goto L236 (error at __call__:-1) else goto L168 :: bool
L168:
    r198 = load_address r3
    r199 = __mypyc_self__.__mypyc_temp__6
    if is_error(r199) goto L236 (error at __call__:-1) else goto L169
L169:
    r200 = CPy_YieldFromErrorHandle(r199, r198)
    dec_ref r199
    if is_error(r200) goto L236 (error at __call__:247) else goto L170
L170:
    if r200 goto L173 else goto L171 :: bool
L171:
    r192 = r3
    r201 = __mypyc_self__.__mypyc_temp__7
    if is_error(r201) goto L237 (error at __call__:-1) else goto L172
L172:
    CPy_RestoreExcInfo(r201)
    dec_ref r201
    goto L162
L173:
    r189 = r3
    r202 = __mypyc_self__.__mypyc_temp__7
    if is_error(r202) goto L238 (error at __call__:-1) else goto L174
L174:
    CPy_RestoreExcInfo(r202)
    dec_ref r202
    goto L183
L175:
    r203 = __mypyc_self__.__mypyc_temp__7
    if is_error(r203) goto L193 (error at __call__:-1) else goto L176
L176:
    CPy_RestoreExcInfo(r203)
    dec_ref r203
    r204 = CPy_KeepPropagating()
    if not r204 goto L193 else goto L177 :: bool
L177:
    unreachable
L178:
    r205 = __mypyc_self__.__mypyc_temp__6
    if is_error(r205) goto L239 (error at __call__:-1) else goto L179
L179:
    r206 = CPyIter_Send(r205, arg)
    dec_ref r205
    dec_ref arg
    if is_error(r206) goto L181 else goto L180
L180:
    r192 = r206
    goto L162
L181:
    r207 = CPy_FetchStopIterationValue()
    if is_error(r207) goto L193 (error at __call__:247) else goto L182
L182:
    r189 = r207
L183:
    __mypyc_self__.__mypyc_next_label__ = -1
L184:
    if is_error(stop_iter_ptr) goto L185 else goto L187
L185:
    CPyGen_SetStopIterationValue(r189)
    dec_ref r189
    if not 0 goto L193 else goto L186 :: bool
L186:
    unreachable
L187:
    set_mem stop_iter_ptr, r189 :: builtins.object*
    return 0
L188:
    r209 = r4 == 0
    if r209 goto L240 else goto L189 :: bool
L189:
    r210 = r4 == 1
    if r210 goto L241 else goto L242 :: bool
L190:
    r211 = r4 == 2
    if r211 goto L163 else goto L243 :: bool
L191:
    r212 = raise StopIteration
    if not r212 goto L193 (error at __call__:212) else goto L192 :: bool
L192:
    unreachable
L193:
    r213 = <error> :: object
    return r213
L194:
    dec_ref r12
    goto L193
L195:
    dec_ref r23
    goto L193
L196:
    dec_ref r23
    dec_ref r24
    goto L193
L197:
    dec_ref r32
    goto L193
L198:
    dec_ref r40
    goto L193
L199:
    dec_ref r43
    goto L193
L200:
    dec_ref r47
    goto L193
L201:
    dec_ref r53
    goto L48
L202:
    dec_ref r53
    goto L193
L203:
    dec_ref r64
    goto L193
L204:
    xdec_ref r1
    goto L62
L205:
    xdec_ref r1
    goto L61
L206:
    xdec_ref r1
    goto L71
L207:
    dec_ref r67
    goto L71
L208:
    dec_ref r64
    goto L71
L209:
    dec_ref arg
    goto L193
L210:
    dec_ref r84
    goto L193
L211:
    dec_ref r90
    goto L193
L212:
    dec_ref r96
    goto L193
L213:
    dec_ref r96
    dec_ref r97
    goto L193
L214:
    dec_ref r97
    dec_ref r98
    goto L193
L215:
    dec_ref r97
    dec_ref r100
    goto L193
L216:
    dec_ref r104
    goto L193
L217:
    dec_ref r104
    dec_ref r105
    goto L193
L218:
    dec_ref r112
    goto L193
L219:
    dec_ref r116
    goto L193
L220:
    dec_ref r116
    dec_ref r119
    goto L193
L221:
    dec_ref r116
    dec_ref r119
    dec_ref r120
    goto L193
L222:
    dec_ref r116
    dec_ref r119
    dec_ref r120
    dec_ref r121
    goto L115
L223:
    dec_ref r116
    dec_ref r119
    dec_ref r120
    dec_ref r121
    goto L193
L224:
    dec_ref r116
    dec_ref r126
    goto L193
L225:
    dec_ref r130
    goto L119
L226:
    dec_ref r133
    goto L193
L227:
    dec_ref r135
    goto L193
L228:
    dec_ref r135
    dec_ref r136
    goto L193
L229:
    dec_ref r158
    goto L193
L230:
    dec_ref r175
    goto L193
L231:
    dec_ref r178
    goto L152
L232:
    dec_ref r178
    goto L193
L233:
    dec_ref r189
    goto L193
L234:
    xdec_ref r3
    goto L166
L235:
    xdec_ref r3
    goto L165
L236:
    xdec_ref r3
    goto L175
L237:
    dec_ref r192
    goto L175
L238:
    dec_ref r189
    goto L175
L239:
    dec_ref arg
    goto L193
L240:
    xdec_ref r1
    xdec_ref r3
    goto L1
L241:
    xdec_ref r3
    goto L59
L242:
    xdec_ref r1
    goto L190
L243:
    xdec_ref r3
    goto L191

def __call____LRUCacheWrapper_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __call____LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __call____LRUCacheWrapper_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __call____LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __call____LRUCacheWrapper_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __call____LRUCacheWrapper_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __call____LRUCacheWrapper_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __call____LRUCacheWrapper_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def __call____LRUCacheWrapper_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapper_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _LRUCacheWrapper.__call__(self, fn_args, fn_kwargs):
    self :: faster_async_lru._LRUCacheWrapper
    fn_args :: tuple
    fn_kwargs :: dict
    r0 :: faster_async_lru.__call____LRUCacheWrapper_gen
    r1, r2, r3, r4 :: bool
    r5 :: faster_async_lru.__call____LRUCacheWrapper_gen
L0:
    r0 = __call____LRUCacheWrapper_gen()
    if is_error(r0) goto L5 (error at __call__:212) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L6 (error at __call__:212) else goto L2 :: bool
L2:
    inc_ref fn_args
    r0.__mypyc_generator_attribute__fn_args = fn_args; r3 = is_error
    if not r3 goto L6 (error at __call__:212) else goto L3 :: bool
L3:
    inc_ref fn_kwargs
    r0.__mypyc_generator_attribute__fn_kwargs = fn_kwargs; r4 = is_error
    if not r4 goto L6 (error at __call__:212) else goto L4 :: bool
L4:
    return r0
L5:
    r5 = <error> :: faster_async_lru.__call____LRUCacheWrapper_gen
    return r5
L6:
    dec_ref r0
    goto L5

def _LRUCacheWrapper.__get__(self, instance, owner):
    self :: faster_async_lru._LRUCacheWrapper
    instance :: object
    owner :: union[object, None]
    r0 :: object
    r1 :: bit
    r2 :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r3 :: union[faster_async_lru._LRUCacheWrapper, faster_async_lru._LRUCacheWrapperInstanceMethod]
L0:
    r0 = load_address _Py_NoneStruct
    r1 = owner == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref self
    return self
L2:
    r2 = _LRUCacheWrapperInstanceMethod(self, instance)
    if is_error(r2) goto L4 (error at __get__:255) else goto L3
L3:
    return r2
L4:
    r3 = <error> :: union[faster_async_lru._LRUCacheWrapper, faster_async_lru._LRUCacheWrapperInstanceMethod]
    return r3

def _LRUCacheWrapperInstanceMethod.__init__(self, wrapper, instance):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    wrapper :: faster_async_lru._LRUCacheWrapper
    instance :: object
    r0 :: str
    r1 :: bool
    r2 :: tuple[object, object, object]
    r3 :: object
    r4 :: str
    r5 :: object
    r6, r7 :: bit
    r8 :: str
    r9 :: bool
    r10 :: tuple[object, object, object]
    r11 :: object
    r12 :: str
    r13 :: object
    r14, r15 :: bit
    r16 :: str
    r17 :: bool
    r18 :: tuple[object, object, object]
    r19 :: object
    r20 :: str
    r21 :: object
    r22, r23 :: bit
    r24 :: union[str, None]
    r25 :: bool
    r26 :: tuple[object, object, object]
    r27 :: object
    r28 :: str
    r29 :: object
    r30, r31 :: bit
    r32 :: dict
    r33 :: bool
    r34 :: tuple[object, object, object]
    r35 :: object
    r36 :: str
    r37 :: object
    r38, r39 :: bit
    r40, r41 :: dict
    r42 :: bool
    r43 :: tuple[object, object, object]
    r44 :: object
    r45 :: str
    r46 :: object
    r47, r48 :: bit
    r49 :: object
    r50 :: str
    r51 :: object
    r52 :: tuple
    r53 :: tuple[int, int]
    r54, r55 :: object
    r56 :: bool
    r57 :: dict
    r58 :: str
    r59 :: object
    r60 :: bool
    r61 :: object
    r62, r63, r64 :: bool
    r65 :: None
L0:
L1:
    r0 = wrapper.__module__
    if is_error(r0) goto L3 (error at __init__:266) else goto L2
L2:
    self.__module__ = r0; r1 = is_error
    if not r1 goto L3 (error at __init__:266) else goto L10 :: bool
L3:
    r2 = CPy_CatchError()
    r3 = builtins :: module
    r4 = 'AttributeError'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L8 (error at __init__:267) else goto L4
L4:
    r6 = CPy_ExceptionMatches(r5)
    dec_ref r5
    if r6 goto L7 else goto L5 :: bool
L5:
    CPy_Reraise()
    if not 0 goto L8 else goto L69 :: bool
L6:
    unreachable
L7:
    CPy_RestoreExcInfo(r2)
    dec_ref r2
    goto L10
L8:
    CPy_RestoreExcInfo(r2)
    dec_ref r2
    r7 = CPy_KeepPropagating()
    if not r7 goto L68 else goto L9 :: bool
L9:
    unreachable
L10:
    r8 = wrapper.__name__
    if is_error(r8) goto L12 (error at __init__:270) else goto L11
L11:
    self.__name__ = r8; r9 = is_error
    if not r9 goto L12 (error at __init__:270) else goto L19 :: bool
L12:
    r10 = CPy_CatchError()
    r11 = builtins :: module
    r12 = 'AttributeError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L17 (error at __init__:271) else goto L13
L13:
    r14 = CPy_ExceptionMatches(r13)
    dec_ref r13
    if r14 goto L16 else goto L14 :: bool
L14:
    CPy_Reraise()
    if not 0 goto L17 else goto L70 :: bool
L15:
    unreachable
L16:
    CPy_RestoreExcInfo(r10)
    dec_ref r10
    goto L19
L17:
    CPy_RestoreExcInfo(r10)
    dec_ref r10
    r15 = CPy_KeepPropagating()
    if not r15 goto L68 else goto L18 :: bool
L18:
    unreachable
L19:
    r16 = wrapper.__qualname__
    if is_error(r16) goto L21 (error at __init__:274) else goto L20
L20:
    self.__qualname__ = r16; r17 = is_error
    if not r17 goto L21 (error at __init__:274) else goto L28 :: bool
L21:
    r18 = CPy_CatchError()
    r19 = builtins :: module
    r20 = 'AttributeError'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L26 (error at __init__:275) else goto L22
L22:
    r22 = CPy_ExceptionMatches(r21)
    dec_ref r21
    if r22 goto L25 else goto L23 :: bool
L23:
    CPy_Reraise()
    if not 0 goto L26 else goto L71 :: bool
L24:
    unreachable
L25:
    CPy_RestoreExcInfo(r18)
    dec_ref r18
    goto L28
L26:
    CPy_RestoreExcInfo(r18)
    dec_ref r18
    r23 = CPy_KeepPropagating()
    if not r23 goto L68 else goto L27 :: bool
L27:
    unreachable
L28:
    r24 = wrapper.__doc__
    if is_error(r24) goto L30 (error at __init__:278) else goto L29
L29:
    self.__doc__ = r24; r25 = is_error
    if not r25 goto L30 (error at __init__:278) else goto L37 :: bool
L30:
    r26 = CPy_CatchError()
    r27 = builtins :: module
    r28 = 'AttributeError'
    r29 = CPyObject_GetAttr(r27, r28)
    if is_error(r29) goto L35 (error at __init__:279) else goto L31
L31:
    r30 = CPy_ExceptionMatches(r29)
    dec_ref r29
    if r30 goto L34 else goto L32 :: bool
L32:
    CPy_Reraise()
    if not 0 goto L35 else goto L72 :: bool
L33:
    unreachable
L34:
    CPy_RestoreExcInfo(r26)
    dec_ref r26
    goto L37
L35:
    CPy_RestoreExcInfo(r26)
    dec_ref r26
    r31 = CPy_KeepPropagating()
    if not r31 goto L68 else goto L36 :: bool
L36:
    unreachable
L37:
    r32 = wrapper.__annotations__
    if is_error(r32) goto L39 (error at __init__:282) else goto L38
L38:
    self.__annotations__ = r32; r33 = is_error
    if not r33 goto L39 (error at __init__:282) else goto L46 :: bool
L39:
    r34 = CPy_CatchError()
    r35 = builtins :: module
    r36 = 'AttributeError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L44 (error at __init__:283) else goto L40
L40:
    r38 = CPy_ExceptionMatches(r37)
    dec_ref r37
    if r38 goto L43 else goto L41 :: bool
L41:
    CPy_Reraise()
    if not 0 goto L44 else goto L73 :: bool
L42:
    unreachable
L43:
    CPy_RestoreExcInfo(r34)
    dec_ref r34
    goto L46
L44:
    CPy_RestoreExcInfo(r34)
    dec_ref r34
    r39 = CPy_KeepPropagating()
    if not r39 goto L68 else goto L45 :: bool
L45:
    unreachable
L46:
    r40 = wrapper.__dict__
    if is_error(r40) goto L49 (error at __init__:286) else goto L47
L47:
    r41 = PyDict_Copy(r40)
    dec_ref r40
    if is_error(r41) goto L49 (error at __init__:286) else goto L48
L48:
    self.__dict__ = r41; r42 = is_error
    if not r42 goto L49 (error at __init__:286) else goto L56 :: bool
L49:
    r43 = CPy_CatchError()
    r44 = builtins :: module
    r45 = 'AttributeError'
    r46 = CPyObject_GetAttr(r44, r45)
    if is_error(r46) goto L54 (error at __init__:287) else goto L50
L50:
    r47 = CPy_ExceptionMatches(r46)
    dec_ref r46
    if r47 goto L53 else goto L51 :: bool
L51:
    CPy_Reraise()
    if not 0 goto L54 else goto L74 :: bool
L52:
    unreachable
L53:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    goto L56
L54:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    r48 = CPy_KeepPropagating()
    if not r48 goto L68 else goto L55 :: bool
L55:
    unreachable
L56:
    r49 = sys :: module
    r50 = 'version_info'
    r51 = CPyObject_GetAttr(r49, r50)
    if is_error(r51) goto L68 (error at __init__:291) else goto L57
L57:
    r52 = cast(tuple, r51)
    if is_error(r52) goto L68 (error at __init__:291) else goto L58
L58:
    r53 = (6, 28)
    r54 = box(tuple[int, int], r53)
    r55 = PyObject_RichCompare(r52, r54, 0)
    dec_ref r52
    dec_ref r54
    if is_error(r55) goto L68 (error at __init__:291) else goto L59
L59:
    r56 = unbox(bool, r55)
    dec_ref r55
    if is_error(r56) goto L68 (error at __init__:291) else goto L60
L60:
    if r56 goto L61 else goto L63 :: bool
L61:
    r57 = faster_async_lru.globals :: static
    r58 = '_is_coroutine'
    r59 = CPyDict_GetItem(r57, r58)
    if is_error(r59) goto L68 (error at __init__:292) else goto L62
L62:
    self._is_coroutine = r59; r60 = is_error
    if not r60 goto L68 (error at __init__:292) else goto L63 :: bool
L63:
    r61 = wrapper.__wrapped__
    if is_error(r61) goto L68 (error at __init__:293) else goto L64
L64:
    self.__wrapped__ = r61; r62 = is_error
    if not r62 goto L68 (error at __init__:293) else goto L65 :: bool
L65:
    inc_ref instance
    self.__instance = instance; r63 = is_error
    if not r63 goto L68 (error at __init__:294) else goto L66 :: bool
L66:
    inc_ref wrapper
    self.__wrapper = wrapper; r64 = is_error
    if not r64 goto L68 (error at __init__:295) else goto L67 :: bool
L67:
    return 1
L68:
    r65 = <error> :: None
    return r65
L69:
    dec_ref r2
    goto L6
L70:
    dec_ref r10
    goto L15
L71:
    dec_ref r18
    goto L24
L72:
    dec_ref r26
    goto L33
L73:
    dec_ref r34
    goto L42
L74:
    dec_ref r43
    goto L52

def _LRUCacheWrapperInstanceMethod.cache_invalidate(self, args, kwargs):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    args :: tuple
    kwargs :: dict
    r0 :: faster_async_lru._LRUCacheWrapper
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: list
    r5, r6 :: ptr
    r7 :: object
    r8 :: dict
    r9 :: i32
    r10 :: bit
    r11 :: tuple
    r12 :: object
    r13, r14 :: bool
L0:
    r0 = self.__wrapper
    if is_error(r0) goto L11 (error at cache_invalidate:298) else goto L1
L1:
    r1 = self.__instance
    if is_error(r1) goto L12 (error at cache_invalidate:298) else goto L2
L2:
    r2 = 'cache_invalidate'
    r3 = CPyObject_GetAttr(r0, r2)
    dec_ref r0
    if is_error(r3) goto L13 (error at cache_invalidate:298) else goto L3
L3:
    r4 = PyList_New(1)
    if is_error(r4) goto L14 (error at cache_invalidate:298) else goto L4
L4:
    r5 = get_element_ptr r4 ob_item :: PyListObject
    r6 = load_mem r5 :: ptr*
    set_mem r6, r1 :: builtins.object*
    r7 = CPyList_Extend(r4, args)
    if is_error(r7) goto L15 (error at cache_invalidate:298) else goto L16
L5:
    r8 = PyDict_New()
    if is_error(r8) goto L15 (error at cache_invalidate:298) else goto L6
L6:
    r9 = CPyDict_UpdateInDisplay(r8, kwargs)
    r10 = r9 >= 0 :: signed
    if not r10 goto L17 (error at cache_invalidate:298) else goto L7 :: bool
L7:
    r11 = PyList_AsTuple(r4)
    dec_ref r4
    if is_error(r11) goto L18 (error at cache_invalidate:298) else goto L8
L8:
    r12 = PyObject_Call(r3, r11, r8)
    dec_ref r3
    dec_ref r11
    dec_ref r8
    if is_error(r12) goto L11 (error at cache_invalidate:298) else goto L9
L9:
    r13 = unbox(bool, r12)
    dec_ref r12
    if is_error(r13) goto L11 (error at cache_invalidate:298) else goto L10
L10:
    return r13
L11:
    r14 = <error> :: bool
    return r14
L12:
    dec_ref r0
    goto L11
L13:
    dec_ref r1
    goto L11
L14:
    dec_ref r1
    dec_ref r3
    goto L11
L15:
    dec_ref r3
    dec_ref r4
    goto L11
L16:
    dec_ref r7
    goto L5
L17:
    dec_ref r3
    dec_ref r4
    dec_ref r8
    goto L11
L18:
    dec_ref r3
    dec_ref r8
    goto L11

def _LRUCacheWrapperInstanceMethod.cache_clear(self):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r0 :: faster_async_lru._LRUCacheWrapper
    r1, r2 :: None
L0:
    r0 = self.__wrapper
    if is_error(r0) goto L3 (error at cache_clear:301) else goto L1
L1:
    r1 = r0.cache_clear()
    dec_ref r0
    if is_error(r1) goto L3 (error at cache_clear:301) else goto L2
L2:
    return 1
L3:
    r2 = <error> :: None
    return r2

def cache_close__LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: object
    r6 :: bit
    r7 :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r8 :: faster_async_lru._LRUCacheWrapper
    r9 :: bool
    r10 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r11 :: bool
    r12 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r13, r14 :: object
    r15 :: object_ptr
    r16 :: object
    r17 :: bit
    r18 :: object
    r19 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r20 :: bool
    r21 :: object
    r22 :: bool
    r23 :: object
    r24 :: bit
    r25 :: tuple[object, object, object]
    r26 :: bool
    r27 :: object_ptr
    r28 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r29 :: bool
    r30, r31, r32 :: tuple[object, object, object]
    r33 :: bit
    r34 :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    r35, r36, r37 :: object
    r38 :: bool
    r39, r40 :: bit
    r41 :: bool
    r42 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    xdec_ref r1
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_next_label__
    goto L39
L1:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L43 (error at cache_close:303) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r7) goto L43 (error at cache_close:306) else goto L5
L5:
    r8 = r7.__wrapper
    dec_ref r7
    if is_error(r8) goto L43 (error at cache_close:306) else goto L6
L6:
    r9 = <error> :: bool
    r10 = r8.cache_close(r9)
    dec_ref r8
    if is_error(r10) goto L43 (error at cache_close:306) else goto L7
L7:
    __mypyc_self__.__mypyc_temp__8 = r10; r11 = is_error
    if not r11 goto L43 (error at cache_close:-1) else goto L8 :: bool
L8:
    r12 = __mypyc_self__.__mypyc_temp__8
    if is_error(r12) goto L43 (error at cache_close:-1) else goto L9
L9:
    r13 = load_address _Py_NoneStruct
    r14 = <error> :: object
    r1 = r14
    r15 = load_address r1
    r16 = r12.__mypyc_generator_helper__(r13, r13, r13, r13, r15)
    dec_ref r12
    if is_error(r16) goto L10 else goto L44
L10:
    r17 = r1 != 0
    if not r17 goto L45 (error at cache_close:-1) else goto L11 :: bool
L11:
    r18 = r1
    dec_ref r18
    r19 = <error> :: faster_async_lru.cache_close__LRUCacheWrapper_gen
    __mypyc_self__.__mypyc_temp__8 = r19; r20 = is_error
    if not r20 goto L43 (error at cache_close:306) else goto L34 :: bool
L12:
    r21 = r16
L13:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r21
L14:
    r23 = load_address _Py_NoneStruct
    r24 = type != r23
    if r24 goto L15 else goto L46 :: bool
L15:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L18 (error at cache_close:306) else goto L47 :: bool
L16:
    unreachable
L17:
    inc_ref arg
    goto L29
L18:
    r25 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__9 = r25; r26 = is_error
    if not r26 goto L48 (error at cache_close:-1) else goto L19 :: bool
L19:
    r27 = load_address r3
    r28 = __mypyc_self__.__mypyc_temp__8
    if is_error(r28) goto L48 (error at cache_close:-1) else goto L20
L20:
    r29 = CPy_YieldFromErrorHandle(r28, r27)
    dec_ref r28
    if is_error(r29) goto L48 (error at cache_close:306) else goto L21
L21:
    if r29 goto L24 else goto L22 :: bool
L22:
    r21 = r3
    r30 = __mypyc_self__.__mypyc_temp__9
    if is_error(r30) goto L49 (error at cache_close:-1) else goto L23
L23:
    CPy_RestoreExcInfo(r30)
    dec_ref r30
    goto L13
L24:
    r18 = r3
    dec_ref r18
    r31 = __mypyc_self__.__mypyc_temp__9
    if is_error(r31) goto L26 (error at cache_close:-1) else goto L25
L25:
    CPy_RestoreExcInfo(r31)
    dec_ref r31
    goto L34
L26:
    r32 = __mypyc_self__.__mypyc_temp__9
    if is_error(r32) goto L43 (error at cache_close:-1) else goto L27
L27:
    CPy_RestoreExcInfo(r32)
    dec_ref r32
    r33 = CPy_KeepPropagating()
    if not r33 goto L43 else goto L28 :: bool
L28:
    unreachable
L29:
    r34 = __mypyc_self__.__mypyc_temp__8
    if is_error(r34) goto L50 (error at cache_close:-1) else goto L30
L30:
    r35 = CPyIter_Send(r34, arg)
    dec_ref r34
    dec_ref arg
    if is_error(r35) goto L32 else goto L31
L31:
    r21 = r35
    goto L13
L32:
    r36 = CPy_FetchStopIterationValue()
    if is_error(r36) goto L43 (error at cache_close:306) else goto L33
L33:
    r18 = r36
    dec_ref r18
L34:
    r37 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L35:
    if is_error(stop_iter_ptr) goto L36 else goto L38
L36:
    CPyGen_SetStopIterationValue(r37)
    if not 0 goto L43 else goto L37 :: bool
L37:
    unreachable
L38:
    inc_ref r37
    set_mem stop_iter_ptr, r37 :: builtins.object*
    return 0
L39:
    r39 = r4 == 0
    if r39 goto L51 else goto L40 :: bool
L40:
    r40 = r4 == 1
    if r40 goto L14 else goto L52 :: bool
L41:
    r41 = raise StopIteration
    if not r41 goto L43 (error at cache_close:303) else goto L42 :: bool
L42:
    unreachable
L43:
    r42 = <error> :: object
    return r42
L44:
    xdec_ref r1
    goto L12
L45:
    xdec_ref r1
    goto L43
L46:
    xdec_ref r3
    goto L17
L47:
    xdec_ref r3
    goto L16
L48:
    xdec_ref r3
    goto L26
L49:
    dec_ref r21
    goto L26
L50:
    dec_ref arg
    goto L43
L51:
    xdec_ref r3
    goto L1
L52:
    xdec_ref r3
    goto L41

def cache_close__LRUCacheWrapperInstanceMethod_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = cache_close__LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def cache_close__LRUCacheWrapperInstanceMethod_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = cache_close__LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def cache_close__LRUCacheWrapperInstanceMethod_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def cache_close__LRUCacheWrapperInstanceMethod_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = cache_close__LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def cache_close__LRUCacheWrapperInstanceMethod_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def cache_close__LRUCacheWrapperInstanceMethod_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _LRUCacheWrapperInstanceMethod.cache_close(self, cancel, return_exceptions):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    cancel, return_exceptions :: bool
    r0 :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    r1, r2, r3, r4 :: bool
    r5 :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
L0:
    if is_error(cancel) goto L1 else goto L2
L1:
    cancel = 0
L2:
    if is_error(return_exceptions) goto L3 else goto L4
L3:
    return_exceptions = 1
L4:
    r0 = cache_close__LRUCacheWrapperInstanceMethod_gen()
    if is_error(r0) goto L9 (error at cache_close:303) else goto L5
L5:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L10 (error at cache_close:303) else goto L6 :: bool
L6:
    r0.__mypyc_generator_attribute__cancel = cancel; r3 = is_error
    if not r3 goto L10 (error at cache_close:303) else goto L7 :: bool
L7:
    r0.__mypyc_generator_attribute__return_exceptions = return_exceptions; r4 = is_error
    if not r4 goto L10 (error at cache_close:303) else goto L8 :: bool
L8:
    return r0
L9:
    r5 = <error> :: faster_async_lru.cache_close__LRUCacheWrapperInstanceMethod_gen
    return r5
L10:
    dec_ref r0
    goto L9

def _LRUCacheWrapperInstanceMethod.cache_info(self):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r0 :: faster_async_lru._LRUCacheWrapper
    r1, r2 :: tuple
L0:
    r0 = self.__wrapper
    if is_error(r0) goto L3 (error at cache_info:309) else goto L1
L1:
    r1 = r0.cache_info()
    dec_ref r0
    if is_error(r1) goto L3 (error at cache_info:309) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: tuple
    return r2

def _LRUCacheWrapperInstanceMethod.cache_parameters(self):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r0 :: faster_async_lru._LRUCacheWrapper
    r1, r2 :: dict
L0:
    r0 = self.__wrapper
    if is_error(r0) goto L3 (error at cache_parameters:312) else goto L1
L1:
    r1 = r0.cache_parameters()
    dec_ref r0
    if is_error(r1) goto L3 (error at cache_parameters:312) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: dict
    return r2

def __call____LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1 :: object
    r2 :: i32
    r3 :: object
    r4 :: bit
    r5, r6 :: faster_async_lru._LRUCacheWrapperInstanceMethod
    r7 :: object
    r8 :: tuple
    r9 :: dict
    r10 :: str
    r11 :: object
    r12 :: list
    r13, r14 :: ptr
    r15 :: object
    r16 :: dict
    r17 :: i32
    r18 :: bit
    r19 :: tuple
    r20, r21 :: object
    r22 :: bool
    r23, r24, r25, r26, r27 :: object
    r28 :: bool
    r29 :: object
    r30 :: bool
    r31 :: object
    r32 :: bit
    r33 :: tuple[object, object, object]
    r34 :: bool
    r35 :: object_ptr
    r36 :: object
    r37 :: bool
    r38, r39, r40 :: tuple[object, object, object]
    r41 :: bit
    r42, r43, r44 :: object
    r45 :: bool
    r46, r47 :: bit
    r48 :: bool
    r49 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_next_label__
    goto L49
L1:
    r3 = load_address _Py_NoneStruct
    r4 = type != r3
    if r4 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L53 (error at __call__:314) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r5) goto L53 (error at __call__:315) else goto L5
L5:
    r6 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r6) goto L54 (error at __call__:315) else goto L6
L6:
    r7 = r6.__instance
    dec_ref r6
    if is_error(r7) goto L54 (error at __call__:315) else goto L7
L7:
    r8 = __mypyc_self__.__mypyc_generator_attribute__fn_args
    if is_error(r8) goto L55 (error at __call__:315) else goto L8
L8:
    r9 = __mypyc_self__.__mypyc_generator_attribute__fn_kwargs
    if is_error(r9) goto L56 (error at __call__:315) else goto L9
L9:
    r10 = '__wrapper'
    r11 = CPyObject_GetAttr(r5, r10)
    dec_ref r5
    if is_error(r11) goto L57 (error at __call__:315) else goto L10
L10:
    r12 = PyList_New(1)
    if is_error(r12) goto L58 (error at __call__:315) else goto L11
L11:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r7 :: builtins.object*
    r15 = CPyList_Extend(r12, r8)
    dec_ref r8
    if is_error(r15) goto L59 (error at __call__:315) else goto L60
L12:
    r16 = PyDict_New()
    if is_error(r16) goto L59 (error at __call__:315) else goto L13
L13:
    r17 = CPyDict_UpdateInDisplay(r16, r9)
    dec_ref r9
    r18 = r17 >= 0 :: signed
    if not r18 goto L61 (error at __call__:315) else goto L14 :: bool
L14:
    r19 = PyList_AsTuple(r12)
    dec_ref r12
    if is_error(r19) goto L62 (error at __call__:315) else goto L15
L15:
    r20 = PyObject_Call(r11, r19, r16)
    dec_ref r11
    dec_ref r19
    dec_ref r16
    if is_error(r20) goto L53 (error at __call__:315) else goto L16
L16:
    r21 = CPy_GetCoro(r20)
    dec_ref r20
    if is_error(r21) goto L53 (error at __call__:315) else goto L17
L17:
    __mypyc_self__.__mypyc_temp__10 = r21; r22 = is_error
    if not r22 goto L53 (error at __call__:-1) else goto L18 :: bool
L18:
    r23 = __mypyc_self__.__mypyc_temp__10
    if is_error(r23) goto L53 (error at __call__:-1) else goto L19
L19:
    r24 = CPyIter_Next(r23)
    dec_ref r23
    if is_error(r24) goto L20 else goto L22
L20:
    r25 = CPy_FetchStopIterationValue()
    if is_error(r25) goto L53 (error at __call__:315) else goto L21
L21:
    r26 = r25
    r27 = <error> :: object
    __mypyc_self__.__mypyc_temp__10 = r27; r28 = is_error
    if not r28 goto L63 (error at __call__:315) else goto L44 :: bool
L22:
    r29 = r24
L23:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r29
L24:
    r31 = load_address _Py_NoneStruct
    r32 = type != r31
    if r32 goto L25 else goto L64 :: bool
L25:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L28 (error at __call__:315) else goto L65 :: bool
L26:
    unreachable
L27:
    inc_ref arg
    goto L39
L28:
    r33 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__11 = r33; r34 = is_error
    if not r34 goto L66 (error at __call__:-1) else goto L29 :: bool
L29:
    r35 = load_address r1
    r36 = __mypyc_self__.__mypyc_temp__10
    if is_error(r36) goto L66 (error at __call__:-1) else goto L30
L30:
    r37 = CPy_YieldFromErrorHandle(r36, r35)
    dec_ref r36
    if is_error(r37) goto L66 (error at __call__:315) else goto L31
L31:
    if r37 goto L34 else goto L32 :: bool
L32:
    r29 = r1
    r38 = __mypyc_self__.__mypyc_temp__11
    if is_error(r38) goto L67 (error at __call__:-1) else goto L33
L33:
    CPy_RestoreExcInfo(r38)
    dec_ref r38
    goto L23
L34:
    r26 = r1
    r39 = __mypyc_self__.__mypyc_temp__11
    if is_error(r39) goto L68 (error at __call__:-1) else goto L35
L35:
    CPy_RestoreExcInfo(r39)
    dec_ref r39
    goto L44
L36:
    r40 = __mypyc_self__.__mypyc_temp__11
    if is_error(r40) goto L53 (error at __call__:-1) else goto L37
L37:
    CPy_RestoreExcInfo(r40)
    dec_ref r40
    r41 = CPy_KeepPropagating()
    if not r41 goto L53 else goto L38 :: bool
L38:
    unreachable
L39:
    r42 = __mypyc_self__.__mypyc_temp__10
    if is_error(r42) goto L69 (error at __call__:-1) else goto L40
L40:
    r43 = CPyIter_Send(r42, arg)
    dec_ref r42
    dec_ref arg
    if is_error(r43) goto L42 else goto L41
L41:
    r29 = r43
    goto L23
L42:
    r44 = CPy_FetchStopIterationValue()
    if is_error(r44) goto L53 (error at __call__:315) else goto L43
L43:
    r26 = r44
L44:
    __mypyc_self__.__mypyc_next_label__ = -1
L45:
    if is_error(stop_iter_ptr) goto L46 else goto L48
L46:
    CPyGen_SetStopIterationValue(r26)
    dec_ref r26
    if not 0 goto L53 else goto L47 :: bool
L47:
    unreachable
L48:
    set_mem stop_iter_ptr, r26 :: builtins.object*
    return 0
L49:
    r46 = r2 == 0
    if r46 goto L70 else goto L50 :: bool
L50:
    r47 = r2 == 1
    if r47 goto L24 else goto L71 :: bool
L51:
    r48 = raise StopIteration
    if not r48 goto L53 (error at __call__:314) else goto L52 :: bool
L52:
    unreachable
L53:
    r49 = <error> :: object
    return r49
L54:
    dec_ref r5
    goto L53
L55:
    dec_ref r5
    dec_ref r7
    goto L53
L56:
    dec_ref r5
    dec_ref r7
    dec_ref r8
    goto L53
L57:
    dec_ref r7
    dec_ref r8
    dec_ref r9
    goto L53
L58:
    dec_ref r7
    dec_ref r8
    dec_ref r9
    dec_ref r11
    goto L53
L59:
    dec_ref r9
    dec_ref r11
    dec_ref r12
    goto L53
L60:
    dec_ref r15
    goto L12
L61:
    dec_ref r11
    dec_ref r12
    dec_ref r16
    goto L53
L62:
    dec_ref r11
    dec_ref r16
    goto L53
L63:
    dec_ref r26
    goto L53
L64:
    xdec_ref r1
    goto L27
L65:
    xdec_ref r1
    goto L26
L66:
    xdec_ref r1
    goto L36
L67:
    dec_ref r29
    goto L36
L68:
    dec_ref r26
    goto L36
L69:
    dec_ref arg
    goto L53
L70:
    xdec_ref r1
    goto L1
L71:
    xdec_ref r1
    goto L51

def __call____LRUCacheWrapperInstanceMethod_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __call____LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __call____LRUCacheWrapperInstanceMethod_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __call____LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __call____LRUCacheWrapperInstanceMethod_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __call____LRUCacheWrapperInstanceMethod_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __call____LRUCacheWrapperInstanceMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __call____LRUCacheWrapperInstanceMethod_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def __call____LRUCacheWrapperInstanceMethod_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _LRUCacheWrapperInstanceMethod.__call__(self, fn_args, fn_kwargs):
    self :: faster_async_lru._LRUCacheWrapperInstanceMethod
    fn_args :: tuple
    fn_kwargs :: dict
    r0 :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    r1, r2, r3, r4 :: bool
    r5 :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
L0:
    r0 = __call____LRUCacheWrapperInstanceMethod_gen()
    if is_error(r0) goto L5 (error at __call__:314) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L6 (error at __call__:314) else goto L2 :: bool
L2:
    inc_ref fn_args
    r0.__mypyc_generator_attribute__fn_args = fn_args; r3 = is_error
    if not r3 goto L6 (error at __call__:314) else goto L3 :: bool
L3:
    inc_ref fn_kwargs
    r0.__mypyc_generator_attribute__fn_kwargs = fn_kwargs; r4 = is_error
    if not r4 goto L6 (error at __call__:314) else goto L4 :: bool
L4:
    return r0
L5:
    r5 = <error> :: faster_async_lru.__call____LRUCacheWrapperInstanceMethod_gen
    return r5
L6:
    dec_ref r0
    goto L5

def wrapper__make_wrapper_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def wrapper__make_wrapper_obj.__call__(__mypyc_self__, fn):
    __mypyc_self__ :: faster_async_lru.wrapper__make_wrapper_obj
    fn :: object
    r0 :: faster_async_lru._make_wrapper_env
    origin, r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: bool
    r5 :: tuple[object, object]
    r6 :: object
    r7 :: i32
    r8 :: bit
    r9 :: bool
    r10 :: str
    r11, r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: bool
    r19 :: object
    r20 :: str
    r21 :: object
    r22, r23 :: str
    r24 :: object[2]
    r25 :: object_ptr
    r26 :: object
    r27 :: union[str, None]
    r28 :: object
    r29 :: bit
    r30 :: str
    r31 :: bit
    r32, r33, r34, r35, r36 :: str
    r37 :: object[3]
    r38 :: object_ptr
    r39 :: object
    r40 :: str
    r41 :: list
    r42, r43, r44 :: ptr
    r45 :: str
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: object[1]
    r50 :: object_ptr
    r51 :: object
    r52 :: str
    r53 :: bool
    r54 :: str
    r55 :: object[1]
    r56 :: object_ptr
    r57 :: object
    r58 :: union[int, None]
    r59 :: bool
    r60 :: union[float, None]
    r61 :: faster_async_lru._LRUCacheWrapper
    r62 :: object
    r63 :: str
    r64 :: object
    r65 :: tuple
    r66 :: tuple[int, int]
    r67, r68 :: object
    r69, r70 :: bool
    r71 :: faster_async_lru._LRUCacheWrapper
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L45 (error at wrapper:323) else goto L1
L1:
    inc_ref fn
    origin = fn
L2:
    r1 = faster_async_lru.partial :: static
    if is_error(r1) goto L46 else goto L5
L3:
    r2 = raise NameError('value for final name "partial" was not set')
    if not r2 goto L45 (error at wrapper:326) else goto L4 :: bool
L4:
    unreachable
L5:
    r3 = faster_async_lru.partialmethod :: static
    if is_error(r3) goto L47 else goto L8
L6:
    r4 = raise NameError('value for final name "partialmethod" was not set')
    if not r4 goto L45 (error at wrapper:326) else goto L7 :: bool
L7:
    unreachable
L8:
    inc_ref r1
    inc_ref r3
    r5 = (r1, r3)
    r6 = box(tuple[object, object], r5)
    r7 = PyObject_IsInstance(origin, r6)
    dec_ref r6
    r8 = r7 >= 0 :: signed
    if not r8 goto L48 (error at wrapper:326) else goto L9 :: bool
L9:
    r9 = truncate r7: i32 to builtins.bool
    if r9 goto L10 else goto L12 :: bool
L10:
    r10 = 'func'
    r11 = CPyObject_GetAttr(origin, r10)
    dec_ref origin
    if is_error(r11) goto L49 (error at wrapper:327) else goto L11
L11:
    origin = r11
    goto L2
L12:
    r12 = inspect :: module
    r13 = 'iscoroutinefunction'
    r14 = CPyObject_GetAttr(r12, r13)
    if is_error(r14) goto L48 (error at wrapper:329) else goto L13
L13:
    r15 = [origin]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L48 (error at wrapper:329) else goto L14
L14:
    dec_ref origin
    r18 = unbox(bool, r17)
    dec_ref r17
    if is_error(r18) goto L49 (error at wrapper:329) else goto L15
L15:
    if r18 goto L30 else goto L16 :: bool
L16:
    r19 = os :: module
    r20 = 'environ'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L49 (error at wrapper:329) else goto L17
L17:
    r22 = 'ASYNC_LRU_ALLOW_SYNC'
    r23 = 'get'
    r24 = [r21, r22]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775810, 0)
    if is_error(r26) goto L50 (error at wrapper:329) else goto L18
L18:
    dec_ref r21
    r27 = cast(union[str, None], r26)
    if is_error(r27) goto L49 (error at wrapper:329) else goto L19
L19:
    r28 = load_address _Py_NoneStruct
    r29 = r27 != r28
    if r29 goto L20 else goto L51 :: bool
L20:
    r30 = cast(str, r27)
    if is_error(r30) goto L49 (error at wrapper:329) else goto L21
L21:
    r31 = CPyStr_IsTrue(r30)
    dec_ref r30
    if r31 goto L30 else goto L52 :: bool
L22:
    r32 = ''
    r33 = 'Coroutine function is required, got '
    r34 = '{!r:{}}'
    r35 = ''
    r36 = 'format'
    r37 = [r34, fn, r35]
    r38 = load_address r37
    r39 = PyObject_VectorcallMethod(r36, r38, 9223372036854775811, 0)
    if is_error(r39) goto L45 (error at wrapper:330) else goto L23
L23:
    r40 = cast(str, r39)
    if is_error(r40) goto L45 (error at wrapper:330) else goto L24
L24:
    r41 = PyList_New(2)
    if is_error(r41) goto L53 (error at wrapper:330) else goto L25
L25:
    r42 = get_element_ptr r41 ob_item :: PyListObject
    r43 = load_mem r42 :: ptr*
    inc_ref r33
    set_mem r43, r33 :: builtins.object*
    r44 = r43 + 8
    set_mem r44, r40 :: builtins.object*
    r45 = PyUnicode_Join(r32, r41)
    dec_ref r41
    if is_error(r45) goto L45 (error at wrapper:330) else goto L26
L26:
    r46 = builtins :: module
    r47 = 'RuntimeError'
    r48 = CPyObject_GetAttr(r46, r47)
    if is_error(r48) goto L54 (error at wrapper:330) else goto L27
L27:
    r49 = [r45]
    r50 = load_address r49
    r51 = PyObject_Vectorcall(r48, r50, 1, 0)
    dec_ref r48
    if is_error(r51) goto L54 (error at wrapper:330) else goto L28
L28:
    dec_ref r45
    CPy_Raise(r51)
    dec_ref r51
    if not 0 goto L45 (error at wrapper:330) else goto L29 :: bool
L29:
    unreachable
L30:
    r52 = '_make_unbound_method'
    r53 = PyObject_HasAttr(fn, r52)
    if r53 goto L31 else goto L55 :: bool
L31:
    r54 = '_make_unbound_method'
    r55 = [fn]
    r56 = load_address r55
    r57 = PyObject_VectorcallMethod(r54, r56, 9223372036854775809, 0)
    if is_error(r57) goto L49 (error at wrapper:334) else goto L32
L32:
    fn = r57
L33:
    r58 = r0.maxsize
    if is_error(r58) goto L56 (error at wrapper:336) else goto L34
L34:
    r59 = r0.typed
    if is_error(r59) goto L57 (error at wrapper:336) else goto L35
L35:
    r60 = r0.ttl
    dec_ref r0
    if is_error(r60) goto L58 (error at wrapper:336) else goto L36
L36:
    r61 = _LRUCacheWrapper(fn, r58, r59, r60)
    dec_ref fn
    dec_ref r58
    dec_ref r60
    if is_error(r61) goto L45 (error at wrapper:336) else goto L37
L37:
    r62 = sys :: module
    r63 = 'version_info'
    r64 = CPyObject_GetAttr(r62, r63)
    if is_error(r64) goto L59 (error at wrapper:337) else goto L38
L38:
    r65 = cast(tuple, r64)
    if is_error(r65) goto L59 (error at wrapper:337) else goto L39
L39:
    r66 = (6, 24)
    r67 = box(tuple[int, int], r66)
    r68 = PyObject_RichCompare(r65, r67, 5)
    dec_ref r65
    dec_ref r67
    if is_error(r68) goto L59 (error at wrapper:337) else goto L40
L40:
    r69 = unbox(bool, r68)
    dec_ref r68
    if is_error(r69) goto L59 (error at wrapper:337) else goto L41
L41:
    if r69 goto L60 else goto L44 :: bool
L42:
    r70 = raise RuntimeError('Reached allegedly unreachable code!')
    if not r70 goto L45 (error at wrapper:338) else goto L43 :: bool
L43:
    unreachable
L44:
    return r61
L45:
    r71 = <error> :: faster_async_lru._LRUCacheWrapper
    return r71
L46:
    dec_ref r0
    dec_ref origin
    goto L3
L47:
    dec_ref r0
    dec_ref origin
    goto L6
L48:
    dec_ref r0
    dec_ref origin
    goto L45
L49:
    dec_ref r0
    goto L45
L50:
    dec_ref r0
    dec_ref r21
    goto L45
L51:
    dec_ref r0
    dec_ref r27
    goto L22
L52:
    dec_ref r0
    goto L22
L53:
    dec_ref r40
    goto L45
L54:
    dec_ref r45
    goto L45
L55:
    inc_ref fn
    goto L33
L56:
    dec_ref fn
    dec_ref r0
    goto L45
L57:
    dec_ref fn
    dec_ref r0
    dec_ref r58
    goto L45
L58:
    dec_ref fn
    dec_ref r58
    goto L45
L59:
    dec_ref r61
    goto L45
L60:
    dec_ref r61
    goto L42

def _make_wrapper(maxsize, typed, ttl):
    maxsize :: union[int, None]
    typed :: bool
    ttl :: union[float, None]
    r0 :: object
    r1 :: faster_async_lru._make_wrapper_env
    r2, r3, r4 :: bool
    r5 :: faster_async_lru.wrapper__make_wrapper_obj
    r6 :: bool
    wrapper, r7 :: object
L0:
    if is_error(ttl) goto L1 else goto L10
L1:
    r0 = box(None, 1)
    inc_ref r0
    ttl = r0
L2:
    r1 = _make_wrapper_env()
    if is_error(r1) goto L11 (error at _make_wrapper:318) else goto L3
L3:
    inc_ref maxsize
    r1.maxsize = maxsize; r2 = is_error
    if not r2 goto L12 (error at _make_wrapper:318) else goto L4 :: bool
L4:
    r1.typed = typed; r3 = is_error
    if not r3 goto L12 (error at _make_wrapper:318) else goto L5 :: bool
L5:
    r1.ttl = ttl; r4 = is_error
    if not r4 goto L13 (error at _make_wrapper:318) else goto L6 :: bool
L6:
    r5 = wrapper__make_wrapper_obj()
    if is_error(r5) goto L13 (error at _make_wrapper:323) else goto L7
L7:
    r5.__mypyc_env__ = r1; r6 = is_error
    if not r6 goto L14 (error at _make_wrapper:323) else goto L8 :: bool
L8:
    wrapper = r5
    return wrapper
L9:
    r7 = <error> :: object
    return r7
L10:
    inc_ref ttl
    goto L2
L11:
    dec_ref ttl
    goto L9
L12:
    dec_ref ttl
    dec_ref r1
    goto L9
L13:
    dec_ref r1
    goto L9
L14:
    dec_ref r5
    goto L9

def alru_cache(maxsize, typed, ttl):
    maxsize :: union[int, None, object]
    typed :: bool
    ttl :: union[float, None]
    r0, r1, r2 :: object
    r3, r4 :: bit
    r5 :: union[int, None]
    r6, fn, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: bool
    r14 :: str
    r15 :: bool
    r16, r17, r18 :: object
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22 :: faster_async_lru._LRUCacheWrapper
    r23, r24, r25, r26 :: str
    r27 :: object[3]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: list
    r32, r33, r34 :: ptr
    r35 :: str
    r36 :: object
    r37 :: str
    r38 :: object
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: union[object, faster_async_lru._LRUCacheWrapper]
L0:
    if is_error(maxsize) goto L1 else goto L28
L1:
    r0 = object 128
    inc_ref r0
    maxsize = r0
L2:
    if is_error(typed) goto L3 else goto L4
L3:
    typed = 0
L4:
    if is_error(ttl) goto L5 else goto L29
L5:
    r1 = box(None, 1)
    inc_ref r1
    ttl = r1
L6:
    r2 = load_address _Py_NoneStruct
    r3 = maxsize == r2
    if r3 goto L8 else goto L7 :: bool
L7:
    r4 = PyLong_Check(maxsize)
    if r4 goto L8 else goto L30 :: bool
L8:
    r5 = cast(union[int, None], maxsize)
    if is_error(r5) goto L31 (error at alru_cache:369) else goto L9
L9:
    r6 = _make_wrapper(r5, typed, ttl)
    dec_ref r5
    dec_ref ttl
    if is_error(r6) goto L27 (error at alru_cache:369) else goto L10
L10:
    return r6
L11:
    fn = maxsize
    r7 = builtins :: module
    r8 = 'callable'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L32 (error at alru_cache:373) else goto L12
L12:
    r10 = [fn]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L32 (error at alru_cache:373) else goto L13
L13:
    r13 = unbox(bool, r12)
    dec_ref r12
    if is_error(r13) goto L32 (error at alru_cache:373) else goto L14
L14:
    if r13 goto L16 else goto L15 :: bool
L15:
    r14 = '_make_unbound_method'
    r15 = PyObject_HasAttr(fn, r14)
    if r15 goto L16 else goto L20 :: bool
L16:
    r16 = object 128
    r17 = box(None, 1)
    r18 = _make_wrapper(r16, 0, r17)
    if is_error(r18) goto L32 (error at alru_cache:374) else goto L17
L17:
    r19 = [fn]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r18, r20, 1, 0)
    dec_ref r18
    if is_error(r21) goto L32 (error at alru_cache:374) else goto L18
L18:
    dec_ref fn
    r22 = cast(faster_async_lru._LRUCacheWrapper, r21)
    if is_error(r22) goto L27 (error at alru_cache:374) else goto L19
L19:
    return r22
L20:
    r23 = ''
    r24 = '{!r:{}}'
    r25 = ''
    r26 = 'format'
    r27 = [r24, fn, r25]
    r28 = load_address r27
    r29 = PyObject_VectorcallMethod(r26, r28, 9223372036854775811, 0)
    if is_error(r29) goto L32 (error at alru_cache:376) else goto L21
L21:
    dec_ref fn
    r30 = ' decorating is not supported'
    r31 = PyList_New(2)
    if is_error(r31) goto L33 (error at alru_cache:376) else goto L22
L22:
    r32 = get_element_ptr r31 ob_item :: PyListObject
    r33 = load_mem r32 :: ptr*
    set_mem r33, r29 :: builtins.object*
    inc_ref r30
    r34 = r33 + 8
    set_mem r34, r30 :: builtins.object*
    r35 = PyUnicode_Join(r23, r31)
    dec_ref r31
    if is_error(r35) goto L27 (error at alru_cache:376) else goto L23
L23:
    r36 = builtins :: module
    r37 = 'NotImplementedError'
    r38 = CPyObject_GetAttr(r36, r37)
    if is_error(r38) goto L34 (error at alru_cache:376) else goto L24
L24:
    r39 = [r35]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r38, r40, 1, 0)
    dec_ref r38
    if is_error(r41) goto L34 (error at alru_cache:376) else goto L25
L25:
    dec_ref r35
    CPy_Raise(r41)
    dec_ref r41
    if not 0 goto L27 (error at alru_cache:376) else goto L26 :: bool
L26:
    unreachable
L27:
    r42 = <error> :: union[object, faster_async_lru._LRUCacheWrapper]
    return r42
L28:
    inc_ref maxsize
    goto L2
L29:
    inc_ref ttl
    goto L6
L30:
    dec_ref ttl
    goto L11
L31:
    dec_ref ttl
    goto L27
L32:
    dec_ref fn
    goto L27
L33:
    dec_ref r29
    goto L27
L34:
    dec_ref r35
    goto L27

def __init____HashedSeq_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __init____HashedSeq_obj.__call__(__mypyc_self__, self, tup):
    __mypyc_self__ :: faster_async_lru.__init____HashedSeq_obj
    self :: faster_async_lru._HashedSeq
    tup :: tuple
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: int
    r7 :: str
    r8 :: object
    r9 :: i32
    r10 :: bit
    r11 :: None
L0:
    r0 = load_address _Py_NoneStruct
    r1 = load_address _Py_NoneStruct
    r2 = load_address _Py_NoneStruct
    r3 = PySlice_New(r0, r1, r2)
    if is_error(r3) goto L5 (error at __init__:394) else goto L1
L1:
    r4 = PyObject_SetItem(self, r3, tup)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L5 (error at __init__:394) else goto L2 :: bool
L2:
    r6 = CPyObject_Hash(tup)
    if is_error(r6) goto L5 (error at __init__:395) else goto L3
L3:
    r7 = 'hashvalue'
    r8 = box(int, r6)
    r9 = PyObject_SetAttr(self, r7, r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L5 (error at __init__:395) else goto L4 :: bool
L4:
    return 1
L5:
    r11 = <error> :: None
    return r11

def __hash____HashedSeq_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __hash____HashedSeq_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: faster_async_lru.__hash____HashedSeq_obj
    self :: faster_async_lru._HashedSeq
    r0 :: str
    r1 :: object
    r2, r3 :: int
L0:
    r0 = 'hashvalue'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L3 (error at __hash__:398) else goto L1
L1:
    r2 = unbox(int, r1)
    dec_ref r1
    if is_error(r2) goto L3 (error at __hash__:398) else goto L2
L2:
    return r2
L3:
    r3 = <error> :: int
    return r3

def _make_key(args, kwds, typed):
    args :: tuple
    kwds :: dict
    typed :: bool
    key :: tuple
    r0 :: native_int
    r1 :: short_int
    r2 :: bit
    r3 :: object
    r4 :: str
    r5, r6 :: object
    r7 :: tuple[object]
    r8, r9 :: object
    r10 :: tuple
    r11 :: short_int
    r12 :: native_int
    r13 :: object
    r14 :: tuple[bool, short_int, object, object]
    r15 :: short_int
    r16 :: bool
    r17, r18 :: object
    r19 :: tuple[object, object]
    r20, r21 :: object
    r22 :: tuple
    r23, r24 :: bit
    r25 :: ptr
    r26 :: native_int
    r27 :: tuple
    r28 :: ptr
    r29, r30 :: native_int
    r31 :: bit
    r32, r33 :: object
    r34 :: native_int
    r35 :: object
    r36 :: tuple
    r37 :: native_int
    r38 :: short_int
    r39 :: bit
    r40 :: list
    r41 :: short_int
    r42 :: native_int
    r43 :: object
    r44 :: tuple[bool, short_int, object]
    r45 :: short_int
    r46 :: bool
    r47, r48 :: object
    r49 :: i32
    r50, r51, r52 :: bit
    r53 :: tuple
    r54 :: object
    r55 :: tuple
    r56 :: ptr
    r57 :: native_int
    r58 :: short_int
    r59 :: bit
    r60 :: tuple[object]
    r61, r62, r63 :: object
    r64 :: bit
    r65 :: object
    r66 :: bit
    r67 :: union[str, int, faster_async_lru._HashedSeq]
    r68 :: object
    r69 :: object[1]
    r70 :: object_ptr
    r71 :: object
    r72 :: faster_async_lru._HashedSeq
    r73 :: union[str, int, faster_async_lru._HashedSeq]
L0:
    inc_ref args
    key = args
    r0 = PyDict_Size(kwds)
    r1 = r0 << 1
    r2 = r1 != 0
    if r2 goto L1 else goto L12 :: bool
L1:
    r3 = builtins :: module
    r4 = 'object'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L41 (error at _make_key:418) else goto L2
L2:
    r6 = PyObject_Vectorcall(r5, 0, 0, 0)
    dec_ref r5
    if is_error(r6) goto L41 (error at _make_key:418) else goto L3
L3:
    r7 = (r6)
    r8 = box(tuple[object], r7)
    r9 = PyNumber_InPlaceAdd(key, r8)
    dec_ref key
    dec_ref r8
    if is_error(r9) goto L40 (error at _make_key:418) else goto L4
L4:
    r10 = cast(tuple, r9)
    if is_error(r10) goto L40 (error at _make_key:418) else goto L5
L5:
    key = r10
    r11 = 0
    r12 = PyDict_Size(kwds)
    r13 = CPyDict_GetItemsIter(kwds)
    if is_error(r13) goto L41 (error at _make_key:419) else goto L6
L6:
    r14 = CPyDict_NextItem(r13, r11)
    r15 = r14[1]
    r11 = r15
    r16 = r14[0]
    if r16 goto L7 else goto L42 :: bool
L7:
    r17 = r14[2]
    r18 = r14[3]
    dec_ref r14
    r19 = (r17, r18)
    r20 = box(tuple[object, object], r19)
    r21 = PyNumber_InPlaceAdd(key, r20)
    dec_ref key
    dec_ref r20
    if is_error(r21) goto L43 (error at _make_key:420) else goto L8
L8:
    r22 = cast(tuple, r21)
    if is_error(r22) goto L43 (error at _make_key:420) else goto L9
L9:
    key = r22
L10:
    r23 = CPyDict_CheckSize(kwds, r12)
    if not r23 goto L44 (error at _make_key:419) else goto L6 :: bool
L11:
    r24 = CPy_NoErrOccurred()
    if not r24 goto L41 (error at _make_key:419) else goto L12 :: bool
L12:
    if typed goto L13 else goto L31 :: bool
L13:
    r25 = get_element_ptr args ob_size :: PyVarObject
    r26 = load_mem r25 :: native_int*
    r27 = PyTuple_New(r26)
    if is_error(r27) goto L41 (error at _make_key:422) else goto L14
L14:
    r28 = get_element_ptr args ob_size :: PyVarObject
    r29 = load_mem r28 :: native_int*
    r30 = 0
L15:
    r31 = r30 < r29 :: signed
    if r31 goto L16 else goto L18 :: bool
L16:
    r32 = CPySequenceTuple_GetItemUnsafe(args, r30)
    r33 = CPy_TYPE(r32)
    dec_ref r32
    CPySequenceTuple_SetItemUnsafe(r27, r30, r33)
L17:
    r34 = r30 + 1
    r30 = r34
    goto L15
L18:
    r35 = PyNumber_InPlaceAdd(key, r27)
    dec_ref key
    dec_ref r27
    if is_error(r35) goto L40 (error at _make_key:422) else goto L19
L19:
    r36 = cast(tuple, r35)
    if is_error(r36) goto L40 (error at _make_key:422) else goto L20
L20:
    key = r36
    r37 = PyDict_Size(kwds)
    r38 = r37 << 1
    r39 = r38 != 0
    if r39 goto L21 else goto L37 :: bool
L21:
    r40 = PyList_New(0)
    if is_error(r40) goto L41 (error at _make_key:424) else goto L22
L22:
    r41 = 0
    r42 = PyDict_Size(kwds)
    r43 = CPyDict_GetValuesIter(kwds)
    if is_error(r43) goto L45 (error at _make_key:424) else goto L23
L23:
    r44 = CPyDict_NextValue(r43, r41)
    r45 = r44[1]
    r41 = r45
    r46 = r44[0]
    if r46 goto L24 else goto L46 :: bool
L24:
    r47 = r44[2]
    dec_ref r44
    r48 = CPy_TYPE(r47)
    dec_ref r47
    r49 = PyList_Append(r40, r48)
    dec_ref r48
    r50 = r49 >= 0 :: signed
    if not r50 goto L47 (error at _make_key:424) else goto L25 :: bool
L25:
    r51 = CPyDict_CheckSize(kwds, r42)
    if not r51 goto L47 (error at _make_key:424) else goto L23 :: bool
L26:
    r52 = CPy_NoErrOccurred()
    if not r52 goto L45 (error at _make_key:424) else goto L27 :: bool
L27:
    r53 = PyList_AsTuple(r40)
    dec_ref r40
    if is_error(r53) goto L41 (error at _make_key:424) else goto L28
L28:
    r54 = PyNumber_InPlaceAdd(key, r53)
    dec_ref key
    dec_ref r53
    if is_error(r54) goto L40 (error at _make_key:424) else goto L29
L29:
    r55 = cast(tuple, r54)
    if is_error(r55) goto L40 (error at _make_key:424) else goto L30
L30:
    key = r55
    goto L37
L31:
    r56 = get_element_ptr key ob_size :: PyVarObject
    r57 = load_mem r56 :: native_int*
    r58 = r57 << 1
    r59 = r58 == 2
    if r59 goto L32 else goto L37 :: bool
L32:
    r60 = unbox(tuple[object], key)
    if is_error(r60) goto L41 (error at _make_key:426) else goto L33
L33:
    r61 = r60[0]
    dec_ref r60
    r62 = CPy_TYPE(r61)
    r63 = load_address PyLong_Type
    r64 = r62 == r63
    if r64 goto L48 else goto L34 :: bool
L34:
    r65 = load_address PyUnicode_Type
    r66 = r62 == r65
    dec_ref r62
    if r66 goto L49 else goto L50 :: bool
L35:
    r67 = cast(union[str, int, faster_async_lru._HashedSeq], r61)
    if is_error(r67) goto L40 (error at _make_key:429) else goto L36
L36:
    return r67
L37:
    r68 = faster_async_lru._HashedSeq :: type
    r69 = [key]
    r70 = load_address r69
    r71 = PyObject_Vectorcall(r68, r70, 1, 0)
    if is_error(r71) goto L41 (error at _make_key:430) else goto L38
L38:
    dec_ref key
    r72 = cast(faster_async_lru._HashedSeq, r71)
    if is_error(r72) goto L40 (error at _make_key:430) else goto L39
L39:
    return r72
L40:
    r73 = <error> :: union[str, int, faster_async_lru._HashedSeq]
    return r73
L41:
    dec_ref key
    goto L40
L42:
    dec_ref r13
    dec_ref r14
    goto L11
L43:
    dec_ref r13
    goto L40
L44:
    dec_ref key
    dec_ref r13
    goto L40
L45:
    dec_ref key
    dec_ref r40
    goto L40
L46:
    dec_ref r43
    dec_ref r44
    goto L26
L47:
    dec_ref key
    dec_ref r40
    dec_ref r43
    goto L40
L48:
    dec_ref key
    dec_ref r62
    goto L35
L49:
    dec_ref key
    goto L35
L50:
    dec_ref r61
    goto L37

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5, r6, r7, r8, r9, r10 :: object_ptr
    r11 :: object_ptr[6]
    r12 :: c_ptr
    r13 :: native_int[6]
    r14 :: c_ptr
    r15 :: object
    r16 :: dict
    r17, r18 :: str
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: dict
    r23, r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: object
    r35 :: tuple
    r36 :: tuple[int, int]
    r37, r38 :: object
    r39, r40 :: bool
    r41 :: object
    r42 :: str
    r43 :: dict
    r44, r45 :: object
    r46 :: str
    r47 :: object
    r48 :: tuple
    r49 :: tuple[int, int]
    r50, r51 :: object
    r52 :: bool
    r53 :: object
    r54 :: str
    r55 :: dict
    r56 :: object
    r57 :: str
    r58 :: dict
    r59 :: str
    r60 :: i32
    r61 :: bit
    r62 :: str
    r63 :: tuple[str]
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: i32
    r68 :: bit
    r69 :: str
    r70 :: dict
    r71 :: str
    r72 :: object
    r73 :: object[1]
    r74 :: object_ptr
    r75 :: object
    r76 :: dict
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: str
    r81 :: dict
    r82 :: str
    r83 :: object
    r84 :: object[1]
    r85 :: object_ptr
    r86 :: object
    r87 :: dict
    r88 :: str
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93 :: object
    r94 :: dict
    r95 :: str
    r96 :: object
    r97 :: dict
    r98 :: str
    r99 :: object
    r100 :: dict
    r101 :: str
    r102 :: object
    r103 :: tuple[object, object, object]
    r104, r105 :: object
    r106 :: dict
    r107 :: str
    r108 :: i32
    r109 :: bit
    r110 :: dict
    r111 :: str
    r112, r113 :: object
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: dict
    r118 :: str
    r119, r120 :: object
    r121 :: tuple[object, object]
    r122, r123 :: object
    r124 :: dict
    r125 :: str
    r126 :: i32
    r127 :: bit
    r128 :: dict
    r129 :: str
    r130 :: object
    r131 :: dict
    r132 :: str
    r133 :: object
    r134 :: dict
    r135 :: str
    r136, r137 :: object
    r138, r139 :: str
    r140 :: tuple[object, str, str]
    r141, r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: i32
    r146 :: bit
    r147, r148, r149, r150, r151 :: str
    r152 :: list
    r153, r154, r155, r156, r157 :: ptr
    r158 :: dict
    r159 :: str
    r160 :: object
    r161 :: object[2]
    r162 :: object_ptr
    r163 :: object
    r164 :: dict
    r165 :: str
    r166 :: i32
    r167 :: bit
    r168 :: object
    r169 :: str
    r170 :: object
    r171 :: dict
    r172 :: str
    r173 :: i32
    r174 :: bit
    r175 :: object
    r176 :: str
    r177 :: object
    r178 :: dict
    r179 :: str
    r180 :: i32
    r181 :: bit
    r182 :: object
    r183 :: str
    r184 :: object
    r185 :: dict
    r186 :: str
    r187 :: i32
    r188 :: bit
    r189 :: object
    r190 :: str
    r191 :: object
    r192 :: dict
    r193 :: str
    r194 :: i32
    r195 :: bit
    r196 :: object
    r197 :: str
    r198 :: object
    r199 :: dict
    r200 :: str
    r201 :: i32
    r202 :: bit
    r203, r204 :: object
    r205 :: bit
    r206 :: str
    r207 :: object
    r208 :: dict
    r209 :: str
    r210 :: object
    r211 :: str
    r212 :: object
    r213 :: tuple
    r214, r215 :: object
    r216 :: bit
    r217 :: str
    r218 :: object
    r219 :: dict
    r220 :: str
    r221 :: object
    r222 :: str
    r223 :: object
    r224 :: str
    r225 :: bool
    r226, r227 :: str
    r228 :: object
    r229 :: object[2]
    r230 :: object_ptr
    r231 :: object
    r232, r233, r234, r235 :: dict
    r236 :: object
    r237 :: str
    r238 :: i32
    r239 :: bit
    r240 :: object
    r241 :: str
    r242 :: i32
    r243 :: bit
    r244 :: object
    r245 :: str
    r246 :: i32
    r247 :: bit
    r248 :: object
    r249 :: str
    r250 :: i32
    r251 :: bit
    r252, r253 :: str
    r254 :: i32
    r255 :: bit
    r256, r257 :: str
    r258 :: i32
    r259 :: bit
    r260, r261 :: str
    r262 :: i32
    r263 :: bit
    r264 :: object[3]
    r265 :: object_ptr
    r266 :: object
    r267 :: dict
    r268 :: str
    r269 :: object
    r270 :: object[1]
    r271 :: object_ptr
    r272 :: object
    r273 :: dict
    r274 :: str
    r275 :: i32
    r276 :: bit
    r277 :: object
    r278 :: dict
    r279 :: str
    r280 :: object
    r281 :: dict
    r282 :: str
    r283, r284 :: object
    r285 :: tuple
    r286 :: str
    r287, r288 :: object
    r289 :: bool
    r290, r291, r292, r293 :: str
    r294 :: tuple
    r295 :: i32
    r296 :: bit
    r297 :: dict
    r298 :: str
    r299 :: i32
    r300 :: bit
    r301 :: dict
    r302 :: tuple[]
    r303 :: dict
    r304, r305 :: object
    r306 :: str
    r307 :: object
    r308 :: str
    r309 :: i32
    r310 :: bit
    r311 :: object
    r312 :: str
    r313 :: i32
    r314 :: bit
    r315 :: str
    r316 :: i32
    r317 :: bit
    r318, r319 :: str
    r320 :: i32
    r321 :: bit
    r322, r323 :: str
    r324 :: i32
    r325 :: bit
    r326 :: object
    r327 :: str
    r328 :: object
    r329 :: str
    r330 :: bit
    r331 :: dict
    r332 :: str
    r333 :: object
    r334 :: dict
    r335 :: str
    r336, r337 :: object
    r338 :: tuple
    r339 :: str
    r340, r341 :: object
    r342 :: bool
    r343, r344, r345, r346, r347, r348, r349, r350, r351, r352, r353, r354, r355, r356, r357, r358, r359, r360 :: str
    r361 :: tuple
    r362 :: i32
    r363 :: bit
    r364 :: dict
    r365 :: str
    r366 :: i32
    r367 :: bit
    r368 :: dict
    r369 :: str
    r370 :: object
    r371 :: dict
    r372 :: str
    r373 :: object
    r374 :: dict
    r375 :: str
    r376 :: object
    r377 :: tuple[object, object]
    r378, r379 :: object
    r380 :: tuple
    r381 :: str
    r382, r383 :: object
    r384 :: bool
    r385, r386, r387, r388, r389, r390, r391, r392, r393, r394, r395, r396 :: str
    r397 :: tuple
    r398 :: i32
    r399 :: bit
    r400 :: dict
    r401 :: str
    r402 :: i32
    r403 :: bit
    r404 :: object
    r405 :: str
    r406 :: object
    r407 :: tuple
    r408, r409 :: object
    r410 :: str
    r411 :: bool
    r412, r413 :: str
    r414 :: object
    r415 :: object[2]
    r416 :: object_ptr
    r417 :: object
    r418, r419, r420, r421 :: dict
    r422 :: object
    r423 :: str
    r424 :: i32
    r425 :: bit
    r426, r427 :: str
    r428 :: i32
    r429 :: bit
    r430 :: faster_async_lru.__init____HashedSeq_obj
    r431 :: str
    r432 :: i32
    r433 :: bit
    r434 :: faster_async_lru.__hash____HashedSeq_obj
    r435 :: str
    r436 :: i32
    r437 :: bit
    r438, r439 :: str
    r440 :: i32
    r441 :: bit
    r442, r443 :: str
    r444 :: i32
    r445 :: bit
    r446, r447 :: str
    r448 :: i32
    r449 :: bit
    r450 :: object[3]
    r451 :: object_ptr
    r452 :: object
    r453 :: dict
    r454 :: str
    r455, r456 :: object
    r457 :: object[1]
    r458 :: object_ptr
    r459, r460 :: object
    r461 :: object[1]
    r462 :: object_ptr
    r463 :: object
    r464 :: dict
    r465 :: str
    r466 :: object
    r467 :: object[1]
    r468 :: object_ptr
    r469 :: object
    r470 :: dict
    r471 :: str
    r472 :: i32
    r473 :: bit
    r474 :: object
    r475 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L159 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address asyncio :: module
    r6 = load_address dataclasses :: module
    r7 = load_address functools :: module
    r8 = load_address inspect :: module
    r9 = load_address os :: module
    r10 = load_address sys :: module
    r11 = [r5, r6, r7, r8, r9, r10]
    r12 = load_address r11
    r13 = [1, 2, 3, 4, 5, 6]
    r14 = load_address r13
    r15 = (('asyncio', 'asyncio', 'asyncio'), ('dataclasses', 'dataclasses', 'dataclasses'), ('functools', 'functools', 'functools'), ('inspect', 'inspect', 'inspect'), ('os', 'os', 'os'), ('sys', 'sys', 'sys'))
    r16 = faster_async_lru.globals :: static
    r17 = 'faster_async_lru/__init__.py'
    r18 = '<module>'
    r19 = CPyImport_ImportMany(r15, r12, r16, r17, r18, r14)
    if not r19 goto L159 else goto L4 :: bool
L4:
    r20 = ('namedtuple',)
    r21 = 'collections'
    r22 = faster_async_lru.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L159 (error at <module>:7) else goto L5
L5:
    collections = r23 :: module
    dec_ref r23
    r24 = ('Any', 'Callable', 'Coroutine', 'Final', 'Generic', 'Hashable', 'Optional', 'OrderedDict', 'Type', 'TypedDict', 'TypeVar', 'Union', 'cast', 'final', 'overload')
    r25 = 'typing'
    r26 = faster_async_lru.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L159 (error at <module>:8) else goto L6
L6:
    typing = r27 :: module
    dec_ref r27
    r28 = ('mypyc_attr',)
    r29 = 'mypy_extensions'
    r30 = faster_async_lru.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L159 (error at <module>:26) else goto L7
L7:
    mypy_extensions = r31 :: module
    dec_ref r31
    r32 = sys :: module
    r33 = 'version_info'
    r34 = CPyObject_GetAttr(r32, r33)
    if is_error(r34) goto L159 (error at <module>:29) else goto L8
L8:
    r35 = cast(tuple, r34)
    if is_error(r35) goto L159 (error at <module>:29) else goto L9
L9:
    r36 = (6, 22)
    r37 = box(tuple[int, int], r36)
    r38 = PyObject_RichCompare(r35, r37, 5)
    dec_ref r35
    dec_ref r37
    if is_error(r38) goto L159 (error at <module>:29) else goto L10
L10:
    r39 = unbox(bool, r38)
    dec_ref r38
    if is_error(r39) goto L159 (error at <module>:29) else goto L11
L11:
    if r39 goto L12 else goto L14 :: bool
L12:
    r40 = raise RuntimeError('Reached allegedly unreachable code!')
    if not r40 goto L159 (error at <module>:30) else goto L13 :: bool
L13:
    unreachable
L14:
    r41 = ('Self',)
    r42 = 'typing_extensions'
    r43 = faster_async_lru.globals :: static
    r44 = CPyImport_ImportFromMany(r42, r41, r41, r43)
    if is_error(r44) goto L159 (error at <module>:32) else goto L15
L15:
    typing_extensions = r44 :: module
    dec_ref r44
L16:
    r45 = sys :: module
    r46 = 'version_info'
    r47 = CPyObject_GetAttr(r45, r46)
    if is_error(r47) goto L159 (error at <module>:34) else goto L17
L17:
    r48 = cast(tuple, r47)
    if is_error(r48) goto L159 (error at <module>:34) else goto L18
L18:
    r49 = (6, 28)
    r50 = box(tuple[int, int], r49)
    r51 = PyObject_RichCompare(r48, r50, 0)
    dec_ref r48
    dec_ref r50
    if is_error(r51) goto L159 (error at <module>:34) else goto L19
L19:
    r52 = unbox(bool, r51)
    dec_ref r51
    if is_error(r52) goto L159 (error at <module>:34) else goto L20
L20:
    if r52 goto L21 else goto L23 :: bool
L21:
    r53 = ('_is_coroutine',)
    r54 = 'asyncio.coroutines'
    r55 = faster_async_lru.globals :: static
    r56 = CPyImport_ImportFromMany(r54, r53, r53, r55)
    if is_error(r56) goto L159 (error at <module>:35) else goto L22
L22:
    asyncio.coroutines = r56 :: module
    dec_ref r56
L23:
    r57 = '2.0.5'
    r58 = faster_async_lru.globals :: static
    r59 = '__version__'
    r60 = CPyDict_SetItem(r58, r59, r57)
    r61 = r60 >= 0 :: signed
    if not r61 goto L159 (error at <module>:38) else goto L24 :: bool
L24:
    r62 = 'alru_cache'
    inc_ref r62
    r63 = (r62)
    r64 = faster_async_lru.globals :: static
    r65 = '__all__'
    r66 = box(tuple[str], r63)
    r67 = CPyDict_SetItem(r64, r65, r66)
    dec_ref r66
    r68 = r67 >= 0 :: signed
    if not r68 goto L159 (error at <module>:40) else goto L25 :: bool
L25:
    r69 = '_T'
    r70 = faster_async_lru.globals :: static
    r71 = 'TypeVar'
    r72 = CPyDict_GetItem(r70, r71)
    if is_error(r72) goto L159 (error at <module>:43) else goto L26
L26:
    r73 = [r69]
    r74 = load_address r73
    r75 = PyObject_Vectorcall(r72, r74, 1, 0)
    dec_ref r72
    if is_error(r75) goto L159 (error at <module>:43) else goto L27
L27:
    r76 = faster_async_lru.globals :: static
    r77 = '_T'
    r78 = CPyDict_SetItem(r76, r77, r75)
    dec_ref r75
    r79 = r78 >= 0 :: signed
    if not r79 goto L159 (error at <module>:43) else goto L28 :: bool
L28:
    r80 = '_R'
    r81 = faster_async_lru.globals :: static
    r82 = 'TypeVar'
    r83 = CPyDict_GetItem(r81, r82)
    if is_error(r83) goto L159 (error at <module>:44) else goto L29
L29:
    r84 = [r80]
    r85 = load_address r84
    r86 = PyObject_Vectorcall(r83, r85, 1, 0)
    dec_ref r83
    if is_error(r86) goto L159 (error at <module>:44) else goto L30
L30:
    r87 = faster_async_lru.globals :: static
    r88 = '_R'
    r89 = CPyDict_SetItem(r87, r88, r86)
    dec_ref r86
    r90 = r89 >= 0 :: signed
    if not r90 goto L159 (error at <module>:44) else goto L31 :: bool
L31:
    r91 = faster_async_lru.globals :: static
    r92 = 'Coroutine'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L159 (error at <module>:45) else goto L32
L32:
    r94 = faster_async_lru.globals :: static
    r95 = 'Any'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L160 (error at <module>:45) else goto L33
L33:
    r97 = faster_async_lru.globals :: static
    r98 = 'Any'
    r99 = CPyDict_GetItem(r97, r98)
    if is_error(r99) goto L161 (error at <module>:45) else goto L34
L34:
    r100 = faster_async_lru.globals :: static
    r101 = '_R'
    r102 = CPyDict_GetItem(r100, r101)
    if is_error(r102) goto L162 (error at <module>:45) else goto L35
L35:
    r103 = (r96, r99, r102)
    r104 = box(tuple[object, object, object], r103)
    r105 = PyObject_GetItem(r93, r104)
    dec_ref r93
    dec_ref r104
    if is_error(r105) goto L159 (error at <module>:45) else goto L36
L36:
    r106 = faster_async_lru.globals :: static
    r107 = '_Coro'
    r108 = CPyDict_SetItem(r106, r107, r105)
    dec_ref r105
    r109 = r108 >= 0 :: signed
    if not r109 goto L159 (error at <module>:45) else goto L37 :: bool
L37:
    r110 = faster_async_lru.globals :: static
    r111 = 'Callable'
    r112 = CPyDict_GetItem(r110, r111)
    if is_error(r112) goto L159 (error at <module>:46) else goto L38
L38:
    r113 = load_address _Py_EllipsisObject
    r114 = faster_async_lru.globals :: static
    r115 = '_Coro'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L163 (error at <module>:46) else goto L39
L39:
    r117 = faster_async_lru.globals :: static
    r118 = '_R'
    r119 = CPyDict_GetItem(r117, r118)
    if is_error(r119) goto L164 (error at <module>:46) else goto L40
L40:
    r120 = PyObject_GetItem(r116, r119)
    dec_ref r116
    dec_ref r119
    if is_error(r120) goto L163 (error at <module>:46) else goto L41
L41:
    inc_ref r113
    r121 = (r113, r120)
    r122 = box(tuple[object, object], r121)
    r123 = PyObject_GetItem(r112, r122)
    dec_ref r112
    dec_ref r122
    if is_error(r123) goto L159 (error at <module>:46) else goto L42
L42:
    r124 = faster_async_lru.globals :: static
    r125 = '_CB'
    r126 = CPyDict_SetItem(r124, r125, r123)
    dec_ref r123
    r127 = r126 >= 0 :: signed
    if not r127 goto L159 (error at <module>:46) else goto L43 :: bool
L43:
    r128 = faster_async_lru.globals :: static
    r129 = 'Union'
    r130 = CPyDict_GetItem(r128, r129)
    if is_error(r130) goto L159 (error at <module>:47) else goto L44
L44:
    r131 = faster_async_lru.globals :: static
    r132 = '_CB'
    r133 = CPyDict_GetItem(r131, r132)
    if is_error(r133) goto L165 (error at <module>:47) else goto L45
L45:
    r134 = faster_async_lru.globals :: static
    r135 = '_R'
    r136 = CPyDict_GetItem(r134, r135)
    if is_error(r136) goto L166 (error at <module>:47) else goto L46
L46:
    r137 = PyObject_GetItem(r133, r136)
    dec_ref r133
    dec_ref r136
    if is_error(r137) goto L165 (error at <module>:47) else goto L47
L47:
    r138 = 'functools.partial[_Coro[_R]]'
    r139 = 'functools.partialmethod[_Coro[_R]]'
    inc_ref r138
    inc_ref r139
    r140 = (r137, r138, r139)
    r141 = box(tuple[object, str, str], r140)
    r142 = PyObject_GetItem(r130, r141)
    dec_ref r130
    dec_ref r141
    if is_error(r142) goto L159 (error at <module>:47) else goto L48
L48:
    r143 = faster_async_lru.globals :: static
    r144 = '_CBP'
    r145 = CPyDict_SetItem(r143, r144, r142)
    dec_ref r142
    r146 = r145 >= 0 :: signed
    if not r146 goto L159 (error at <module>:47) else goto L49 :: bool
L49:
    r147 = '_CacheInfo'
    r148 = 'hits'
    r149 = 'misses'
    r150 = 'maxsize'
    r151 = 'currsize'
    r152 = PyList_New(4)
    if is_error(r152) goto L159 (error at <module>:49) else goto L50
L50:
    r153 = get_element_ptr r152 ob_item :: PyListObject
    r154 = load_mem r153 :: ptr*
    inc_ref r148
    set_mem r154, r148 :: builtins.object*
    inc_ref r149
    r155 = r154 + 8
    set_mem r155, r149 :: builtins.object*
    inc_ref r150
    r156 = r154 + 16
    set_mem r156, r150 :: builtins.object*
    inc_ref r151
    r157 = r154 + 24
    set_mem r157, r151 :: builtins.object*
    r158 = faster_async_lru.globals :: static
    r159 = 'namedtuple'
    r160 = CPyDict_GetItem(r158, r159)
    if is_error(r160) goto L167 (error at <module>:49) else goto L51
L51:
    r161 = [r147, r152]
    r162 = load_address r161
    r163 = PyObject_Vectorcall(r160, r162, 2, 0)
    dec_ref r160
    if is_error(r163) goto L167 (error at <module>:49) else goto L52
L52:
    dec_ref r152
    r164 = faster_async_lru.globals :: static
    r165 = '_CacheInfo'
    r166 = CPyDict_SetItem(r164, r165, r163)
    dec_ref r163
    r167 = r166 >= 0 :: signed
    if not r167 goto L159 (error at <module>:49) else goto L53 :: bool
L53:
    r168 = functools :: module
    r169 = 'partial'
    r170 = CPyObject_GetAttr(r168, r169)
    if is_error(r170) goto L159 (error at <module>:52) else goto L54
L54:
    faster_async_lru.partial = r170 :: static
    r171 = faster_async_lru.globals :: static
    r172 = 'partial'
    r173 = CPyDict_SetItem(r171, r172, r170)
    dec_ref r170
    r174 = r173 >= 0 :: signed
    if not r174 goto L159 (error at <module>:52) else goto L55 :: bool
L55:
    r175 = functools :: module
    r176 = 'partialmethod'
    r177 = CPyObject_GetAttr(r175, r176)
    if is_error(r177) goto L159 (error at <module>:53) else goto L56
L56:
    faster_async_lru.partialmethod = r177 :: static
    r178 = faster_async_lru.globals :: static
    r179 = 'partialmethod'
    r180 = CPyDict_SetItem(r178, r179, r177)
    dec_ref r177
    r181 = r180 >= 0 :: signed
    if not r181 goto L159 (error at <module>:53) else goto L57 :: bool
L57:
    r182 = asyncio :: module
    r183 = 'gather'
    r184 = CPyObject_GetAttr(r182, r183)
    if is_error(r184) goto L159 (error at <module>:55) else goto L58
L58:
    faster_async_lru.gather = r184 :: static
    r185 = faster_async_lru.globals :: static
    r186 = 'gather'
    r187 = CPyDict_SetItem(r185, r186, r184)
    dec_ref r184
    r188 = r187 >= 0 :: signed
    if not r188 goto L159 (error at <module>:55) else goto L59 :: bool
L59:
    r189 = asyncio :: module
    r190 = 'get_running_loop'
    r191 = CPyObject_GetAttr(r189, r190)
    if is_error(r191) goto L159 (error at <module>:56) else goto L60
L60:
    faster_async_lru.get_running_loop = r191 :: static
    r192 = faster_async_lru.globals :: static
    r193 = 'get_running_loop'
    r194 = CPyDict_SetItem(r192, r193, r191)
    dec_ref r191
    r195 = r194 >= 0 :: signed
    if not r195 goto L159 (error at <module>:56) else goto L61 :: bool
L61:
    r196 = asyncio :: module
    r197 = 'shield'
    r198 = CPyObject_GetAttr(r196, r197)
    if is_error(r198) goto L159 (error at <module>:57) else goto L62
L62:
    faster_async_lru.shield = r198 :: static
    r199 = faster_async_lru.globals :: static
    r200 = 'shield'
    r201 = CPyDict_SetItem(r199, r200, r198)
    dec_ref r198
    r202 = r201 >= 0 :: signed
    if not r202 goto L159 (error at <module>:57) else goto L63 :: bool
L63:
    r203 = typing :: module
    r204 = load_address _Py_NoneStruct
    r205 = r203 != r204
    if r205 goto L66 else goto L64 :: bool
L64:
    r206 = 'typing'
    r207 = PyImport_Import(r206)
    if is_error(r207) goto L159 (error at <module>:61) else goto L65
L65:
    typing = r207 :: module
    dec_ref r207
L66:
    r208 = PyImport_GetModuleDict()
    r209 = 'typing'
    r210 = CPyDict_GetItem(r208, r209)
    if is_error(r210) goto L159 (error at <module>:61) else goto L67
L67:
    r211 = '_TypedDict'
    r212 = CPyObject_GetAttr(r210, r211)
    dec_ref r210
    if is_error(r212) goto L159 (error at <module>:61) else goto L68
L68:
    r213 = PyTuple_Pack(1, r212)
    dec_ref r212
    if is_error(r213) goto L159 (error at <module>:61) else goto L69
L69:
    r214 = typing :: module
    r215 = load_address _Py_NoneStruct
    r216 = r214 != r215
    if r216 goto L72 else goto L70 :: bool
L70:
    r217 = 'typing'
    r218 = PyImport_Import(r217)
    if is_error(r218) goto L168 (error at <module>:61) else goto L71
L71:
    typing = r218 :: module
    dec_ref r218
L72:
    r219 = PyImport_GetModuleDict()
    r220 = 'typing'
    r221 = CPyDict_GetItem(r219, r220)
    if is_error(r221) goto L168 (error at <module>:61) else goto L73
L73:
    r222 = '_TypedDictMeta'
    r223 = CPyObject_GetAttr(r221, r222)
    dec_ref r221
    if is_error(r223) goto L168 (error at <module>:61) else goto L74
L74:
    r224 = '__prepare__'
    r225 = PyObject_HasAttr(r223, r224)
    if r225 goto L75 else goto L79 :: bool
L75:
    r226 = '_CacheParameters'
    r227 = '__prepare__'
    r228 = CPyObject_GetAttr(r223, r227)
    if is_error(r228) goto L169 (error at <module>:61) else goto L76
L76:
    r229 = [r226, r213]
    r230 = load_address r229
    r231 = PyObject_Vectorcall(r228, r230, 2, 0)
    dec_ref r228
    if is_error(r231) goto L169 (error at <module>:61) else goto L77
L77:
    r232 = cast(dict, r231)
    if is_error(r232) goto L169 (error at <module>:61) else goto L78
L78:
    r233 = r232
    goto L81
L79:
    r234 = PyDict_New()
    if is_error(r234) goto L169 (error at <module>:61) else goto L80
L80:
    r233 = r234
L81:
    r235 = PyDict_New()
    if is_error(r235) goto L170 (error at <module>:61) else goto L82
L82:
    r236 = load_address PyBool_Type
    r237 = 'typed'
    r238 = PyDict_SetItem(r235, r237, r236)
    r239 = r238 >= 0 :: signed
    if not r239 goto L171 (error at <module>:62) else goto L83 :: bool
L83:
    r240 = load_address PyType_Type
    r241 = 'maxsize'
    r242 = PyDict_SetItem(r235, r241, r240)
    r243 = r242 >= 0 :: signed
    if not r243 goto L171 (error at <module>:63) else goto L84 :: bool
L84:
    r244 = load_address PyLong_Type
    r245 = 'tasks'
    r246 = PyDict_SetItem(r235, r245, r244)
    r247 = r246 >= 0 :: signed
    if not r247 goto L171 (error at <module>:64) else goto L85 :: bool
L85:
    r248 = load_address PyBool_Type
    r249 = 'closed'
    r250 = PyDict_SetItem(r235, r249, r248)
    r251 = r250 >= 0 :: signed
    if not r251 goto L171 (error at <module>:65) else goto L86 :: bool
L86:
    r252 = '_CacheParameters'
    r253 = '__annotations__'
    r254 = CPyDict_SetItem(r233, r253, r235)
    dec_ref r235
    r255 = r254 >= 0 :: signed
    if not r255 goto L170 (error at <module>:61) else goto L87 :: bool
L87:
    r256 = 'mypyc filler docstring'
    r257 = '__doc__'
    r258 = CPyDict_SetItem(r233, r257, r256)
    r259 = r258 >= 0 :: signed
    if not r259 goto L170 (error at <module>:61) else goto L88 :: bool
L88:
    r260 = 'faster_async_lru'
    r261 = '__module__'
    r262 = CPyDict_SetItem(r233, r261, r260)
    r263 = r262 >= 0 :: signed
    if not r263 goto L170 (error at <module>:61) else goto L89 :: bool
L89:
    r264 = [r252, r213, r233]
    r265 = load_address r264
    r266 = PyObject_Vectorcall(r223, r265, 3, 0)
    dec_ref r223
    if is_error(r266) goto L172 (error at <module>:61) else goto L90
L90:
    dec_ref r213
    dec_ref r233
    r267 = faster_async_lru.globals :: static
    r268 = 'final'
    r269 = CPyDict_GetItem(r267, r268)
    if is_error(r269) goto L173 (error at <module>:60) else goto L91
L91:
    r270 = [r266]
    r271 = load_address r270
    r272 = PyObject_Vectorcall(r269, r271, 1, 0)
    dec_ref r269
    if is_error(r272) goto L173 (error at <module>:61) else goto L92
L92:
    dec_ref r266
    faster_async_lru._CacheParameters = r272 :: type
    r273 = faster_async_lru.globals :: static
    r274 = '_CacheParameters'
    r275 = PyDict_SetItem(r273, r274, r272)
    dec_ref r272
    r276 = r275 >= 0 :: signed
    if not r276 goto L159 (error at <module>:61) else goto L93 :: bool
L93:
    r277 = faster_async_lru._CacheParameters :: type
    r278 = faster_async_lru.globals :: static
    r279 = 'Generic'
    r280 = CPyDict_GetItem(r278, r279)
    if is_error(r280) goto L159 (error at <module>:70) else goto L94
L94:
    r281 = faster_async_lru.globals :: static
    r282 = '_R'
    r283 = CPyDict_GetItem(r281, r282)
    if is_error(r283) goto L174 (error at <module>:70) else goto L95
L95:
    r284 = PyObject_GetItem(r280, r283)
    dec_ref r280
    dec_ref r283
    if is_error(r284) goto L159 (error at <module>:70) else goto L96
L96:
    r285 = PyTuple_Pack(1, r284)
    dec_ref r284
    if is_error(r285) goto L159 (error at <module>:70) else goto L97
L97:
    r286 = 'faster_async_lru'
    r287 = faster_async_lru._CacheItem_template :: type
    r288 = CPyType_FromTemplate(r287, r285, r286)
    dec_ref r285
    if is_error(r288) goto L159 (error at <module>:70) else goto L98
L98:
    r289 = _CacheItem_trait_vtable_setup()
    if is_error(r289) goto L175 (error at <module>:-1) else goto L99
L99:
    r290 = '__mypyc_attrs__'
    r291 = 'fut'
    r292 = 'later_call'
    r293 = '__dict__'
    r294 = PyTuple_Pack(3, r291, r292, r293)
    if is_error(r294) goto L175 (error at <module>:70) else goto L100
L100:
    r295 = PyObject_SetAttr(r288, r290, r294)
    dec_ref r294
    r296 = r295 >= 0 :: signed
    if not r296 goto L175 (error at <module>:70) else goto L101 :: bool
L101:
    faster_async_lru._CacheItem = r288 :: type
    r297 = faster_async_lru.globals :: static
    r298 = '_CacheItem'
    r299 = PyDict_SetItem(r297, r298, r288)
    r300 = r299 >= 0 :: signed
    if not r300 goto L175 (error at <module>:70) else goto L102 :: bool
L102:
    r301 = PyDict_New()
    if is_error(r301) goto L175 (error at <module>:70) else goto L103
L103:
    r302 = ()
    r303 = PyDict_New()
    if is_error(r303) goto L176 (error at <module>:70) else goto L104
L104:
    r304 = load_address PyType_Type
    r305 = asyncio :: module
    r306 = 'Future'
    r307 = CPyObject_GetAttr(r305, r306)
    if is_error(r307) goto L177 (error at <module>:71) else goto L105
L105:
    r308 = 'fut'
    r309 = PyDict_SetItem(r303, r308, r307)
    dec_ref r307
    r310 = r309 >= 0 :: signed
    if not r310 goto L177 (error at <module>:71) else goto L106 :: bool
L106:
    r311 = load_address PyType_Type
    r312 = 'later_call'
    r313 = PyDict_SetItem(r303, r312, r311)
    r314 = r313 >= 0 :: signed
    if not r314 goto L177 (error at <module>:72) else goto L107 :: bool
L107:
    r315 = '__annotations__'
    r316 = CPyDict_SetItem(r301, r315, r303)
    r317 = r316 >= 0 :: signed
    if not r317 goto L177 (error at <module>:70) else goto L108 :: bool
L108:
    r318 = 'mypyc filler docstring'
    r319 = '__doc__'
    r320 = CPyDict_SetItem(r301, r319, r318)
    r321 = r320 >= 0 :: signed
    if not r321 goto L177 (error at <module>:70) else goto L109 :: bool
L109:
    r322 = 'faster_async_lru'
    r323 = '__module__'
    r324 = CPyDict_SetItem(r301, r323, r322)
    r325 = r324 >= 0 :: signed
    if not r325 goto L177 (error at <module>:70) else goto L110 :: bool
L110:
    r326 = dataclasses :: module
    r327 = 'dataclass'
    r328 = CPyObject_GetAttr(r326, r327)
    if is_error(r328) goto L177 (error at <module>:69) else goto L111
L111:
    r329 = 'dataclasses'
    r330 = CPyDataclass_SleightOfHand(r328, r288, r301, r303, r329)
    dec_ref r328
    dec_ref r288
    dec_ref r301
    dec_ref r303
    if not r330 goto L159 (error at <module>:70) else goto L112 :: bool
L112:
    r331 = faster_async_lru.globals :: static
    r332 = 'Generic'
    r333 = CPyDict_GetItem(r331, r332)
    if is_error(r333) goto L159 (error at <module>:81) else goto L113
L113:
    r334 = faster_async_lru.globals :: static
    r335 = '_R'
    r336 = CPyDict_GetItem(r334, r335)
    if is_error(r336) goto L178 (error at <module>:81) else goto L114
L114:
    r337 = PyObject_GetItem(r333, r336)
    dec_ref r333
    dec_ref r336
    if is_error(r337) goto L159 (error at <module>:81) else goto L115
L115:
    r338 = PyTuple_Pack(1, r337)
    dec_ref r337
    if is_error(r338) goto L159 (error at <module>:81) else goto L116
L116:
    r339 = 'faster_async_lru'
    r340 = faster_async_lru._LRUCacheWrapper_template :: type
    r341 = CPyType_FromTemplate(r340, r338, r339)
    dec_ref r338
    if is_error(r341) goto L159 (error at <module>:81) else goto L117
L117:
    r342 = _LRUCacheWrapper_trait_vtable_setup()
    if is_error(r342) goto L179 (error at <module>:-1) else goto L118
L118:
    r343 = '__mypyc_attrs__'
    r344 = '__module__'
    r345 = '__name__'
    r346 = '__qualname__'
    r347 = '__doc__'
    r348 = '__annotations__'
    r349 = '__dict__'
    r350 = '_is_coroutine'
    r351 = '__wrapped__'
    r352 = '__maxsize'
    r353 = '__typed'
    r354 = '__ttl'
    r355 = '__cache'
    r356 = '__closed'
    r357 = '__hits'
    r358 = '__misses'
    r359 = '__tasks'
    r360 = '__dict__'
    r361 = PyTuple_Pack(17, r344, r345, r346, r347, r348, r349, r350, r351, r352, r353, r354, r355, r356, r357, r358, r359, r360)
    if is_error(r361) goto L179 (error at <module>:81) else goto L119
L119:
    r362 = PyObject_SetAttr(r341, r343, r361)
    dec_ref r361
    r363 = r362 >= 0 :: signed
    if not r363 goto L179 (error at <module>:81) else goto L120 :: bool
L120:
    faster_async_lru._LRUCacheWrapper = r341 :: type
    r364 = faster_async_lru.globals :: static
    r365 = '_LRUCacheWrapper'
    r366 = PyDict_SetItem(r364, r365, r341)
    dec_ref r341
    r367 = r366 >= 0 :: signed
    if not r367 goto L159 (error at <module>:81) else goto L121 :: bool
L121:
    r368 = faster_async_lru.globals :: static
    r369 = 'Generic'
    r370 = CPyDict_GetItem(r368, r369)
    if is_error(r370) goto L159 (error at <module>:259) else goto L122
L122:
    r371 = faster_async_lru.globals :: static
    r372 = '_R'
    r373 = CPyDict_GetItem(r371, r372)
    if is_error(r373) goto L180 (error at <module>:259) else goto L123
L123:
    r374 = faster_async_lru.globals :: static
    r375 = '_T'
    r376 = CPyDict_GetItem(r374, r375)
    if is_error(r376) goto L181 (error at <module>:259) else goto L124
L124:
    r377 = (r373, r376)
    r378 = box(tuple[object, object], r377)
    r379 = PyObject_GetItem(r370, r378)
    dec_ref r370
    dec_ref r378
    if is_error(r379) goto L159 (error at <module>:259) else goto L125
L125:
    r380 = PyTuple_Pack(1, r379)
    dec_ref r379
    if is_error(r380) goto L159 (error at <module>:259) else goto L126
L126:
    r381 = 'faster_async_lru'
    r382 = faster_async_lru._LRUCacheWrapperInstanceMethod_template :: type
    r383 = CPyType_FromTemplate(r382, r380, r381)
    dec_ref r380
    if is_error(r383) goto L159 (error at <module>:259) else goto L127
L127:
    r384 = _LRUCacheWrapperInstanceMethod_trait_vtable_setup()
    if is_error(r384) goto L182 (error at <module>:-1) else goto L128
L128:
    r385 = '__mypyc_attrs__'
    r386 = '__module__'
    r387 = '__name__'
    r388 = '__qualname__'
    r389 = '__doc__'
    r390 = '__annotations__'
    r391 = '__dict__'
    r392 = '_is_coroutine'
    r393 = '__wrapped__'
    r394 = '__instance'
    r395 = '__wrapper'
    r396 = '__dict__'
    r397 = PyTuple_Pack(11, r386, r387, r388, r389, r390, r391, r392, r393, r394, r395, r396)
    if is_error(r397) goto L182 (error at <module>:259) else goto L129
L129:
    r398 = PyObject_SetAttr(r383, r385, r397)
    dec_ref r397
    r399 = r398 >= 0 :: signed
    if not r399 goto L182 (error at <module>:259) else goto L130 :: bool
L130:
    faster_async_lru._LRUCacheWrapperInstanceMethod = r383 :: type
    r400 = faster_async_lru.globals :: static
    r401 = '_LRUCacheWrapperInstanceMethod'
    r402 = PyDict_SetItem(r400, r401, r383)
    dec_ref r383
    r403 = r402 >= 0 :: signed
    if not r403 goto L159 (error at <module>:259) else goto L131 :: bool
L131:
    r404 = builtins :: module
    r405 = 'list'
    r406 = CPyObject_GetAttr(r404, r405)
    if is_error(r406) goto L159 (error at <module>:384) else goto L132
L132:
    r407 = PyTuple_Pack(1, r406)
    dec_ref r406
    if is_error(r407) goto L159 (error at <module>:384) else goto L133
L133:
    r408 = load_address PyType_Type
    r409 = CPy_CalculateMetaclass(r408, r407)
    if is_error(r409) goto L183 (error at <module>:384) else goto L134
L134:
    r410 = '__prepare__'
    r411 = PyObject_HasAttr(r409, r410)
    if r411 goto L135 else goto L139 :: bool
L135:
    r412 = '_HashedSeq'
    r413 = '__prepare__'
    r414 = CPyObject_GetAttr(r409, r413)
    if is_error(r414) goto L183 (error at <module>:384) else goto L136
L136:
    r415 = [r412, r407]
    r416 = load_address r415
    r417 = PyObject_Vectorcall(r414, r416, 2, 0)
    dec_ref r414
    if is_error(r417) goto L183 (error at <module>:384) else goto L137
L137:
    r418 = cast(dict, r417)
    if is_error(r418) goto L183 (error at <module>:384) else goto L138
L138:
    r419 = r418
    goto L141
L139:
    r420 = PyDict_New()
    if is_error(r420) goto L183 (error at <module>:384) else goto L140
L140:
    r419 = r420
L141:
    r421 = PyDict_New()
    if is_error(r421) goto L184 (error at <module>:384) else goto L142
L142:
    r422 = load_address PyUnicode_Type
    r423 = '__slots__'
    r424 = PyDict_SetItem(r421, r423, r422)
    r425 = r424 >= 0 :: signed
    if not r425 goto L185 (error at <module>:391) else goto L143 :: bool
L143:
    r426 = 'hashvalue'
    r427 = '__slots__'
    r428 = CPyDict_SetItem(r419, r427, r426)
    r429 = r428 >= 0 :: signed
    if not r429 goto L185 (error at <module>:391) else goto L144 :: bool
L144:
    r430 = __init____HashedSeq_obj()
    if is_error(r430) goto L185 (error at <module>:393) else goto L145
L145:
    r431 = '__init__'
    r432 = CPyDict_SetItem(r419, r431, r430)
    dec_ref r430
    r433 = r432 >= 0 :: signed
    if not r433 goto L185 (error at <module>:393) else goto L146 :: bool
L146:
    r434 = __hash____HashedSeq_obj()
    if is_error(r434) goto L185 (error at <module>:397) else goto L147
L147:
    r435 = '__hash__'
    r436 = CPyDict_SetItem(r419, r435, r434)
    dec_ref r434
    r437 = r436 >= 0 :: signed
    if not r437 goto L185 (error at <module>:397) else goto L148 :: bool
L148:
    r438 = '_HashedSeq'
    r439 = '__annotations__'
    r440 = CPyDict_SetItem(r419, r439, r421)
    dec_ref r421
    r441 = r440 >= 0 :: signed
    if not r441 goto L184 (error at <module>:384) else goto L149 :: bool
L149:
    r442 = 'mypyc filler docstring'
    r443 = '__doc__'
    r444 = CPyDict_SetItem(r419, r443, r442)
    r445 = r444 >= 0 :: signed
    if not r445 goto L184 (error at <module>:384) else goto L150 :: bool
L150:
    r446 = 'faster_async_lru'
    r447 = '__module__'
    r448 = CPyDict_SetItem(r419, r447, r446)
    r449 = r448 >= 0 :: signed
    if not r449 goto L184 (error at <module>:384) else goto L151 :: bool
L151:
    r450 = [r438, r407, r419]
    r451 = load_address r450
    r452 = PyObject_Vectorcall(r409, r451, 3, 0)
    if is_error(r452) goto L184 (error at <module>:384) else goto L152
L152:
    dec_ref r407
    dec_ref r419
    r453 = faster_async_lru.globals :: static
    r454 = 'mypyc_attr'
    r455 = CPyDict_GetItem(r453, r454)
    if is_error(r455) goto L186 (error at <module>:383) else goto L153
L153:
    r456 = box(bool, 0)
    r457 = [r456]
    r458 = load_address r457
    r459 = ('native_class',)
    r460 = PyObject_Vectorcall(r455, r458, 0, r459)
    dec_ref r455
    if is_error(r460) goto L186 (error at <module>:383) else goto L154
L154:
    r461 = [r452]
    r462 = load_address r461
    r463 = PyObject_Vectorcall(r460, r462, 1, 0)
    dec_ref r460
    if is_error(r463) goto L186 (error at <module>:384) else goto L155
L155:
    dec_ref r452
    r464 = faster_async_lru.globals :: static
    r465 = 'final'
    r466 = CPyDict_GetItem(r464, r465)
    if is_error(r466) goto L187 (error at <module>:382) else goto L156
L156:
    r467 = [r463]
    r468 = load_address r467
    r469 = PyObject_Vectorcall(r466, r468, 1, 0)
    dec_ref r466
    if is_error(r469) goto L187 (error at <module>:384) else goto L157
L157:
    dec_ref r463
    faster_async_lru._HashedSeq = r469 :: type
    r470 = faster_async_lru.globals :: static
    r471 = '_HashedSeq'
    r472 = PyDict_SetItem(r470, r471, r469)
    dec_ref r469
    r473 = r472 >= 0 :: signed
    if not r473 goto L159 (error at <module>:384) else goto L158 :: bool
L158:
    r474 = faster_async_lru._HashedSeq :: type
    return 1
L159:
    r475 = <error> :: None
    return r475
L160:
    dec_ref r93
    goto L159
L161:
    dec_ref r93
    dec_ref r96
    goto L159
L162:
    dec_ref r93
    dec_ref r96
    dec_ref r99
    goto L159
L163:
    dec_ref r112
    goto L159
L164:
    dec_ref r112
    dec_ref r116
    goto L159
L165:
    dec_ref r130
    goto L159
L166:
    dec_ref r130
    dec_ref r133
    goto L159
L167:
    dec_ref r152
    goto L159
L168:
    dec_ref r213
    goto L159
L169:
    dec_ref r213
    dec_ref r223
    goto L159
L170:
    dec_ref r213
    dec_ref r223
    dec_ref r233
    goto L159
L171:
    dec_ref r213
    dec_ref r223
    dec_ref r233
    dec_ref r235
    goto L159
L172:
    dec_ref r213
    dec_ref r233
    goto L159
L173:
    dec_ref r266
    goto L159
L174:
    dec_ref r280
    goto L159
L175:
    dec_ref r288
    goto L159
L176:
    dec_ref r288
    dec_ref r301
    goto L159
L177:
    dec_ref r288
    dec_ref r301
    dec_ref r303
    goto L159
L178:
    dec_ref r333
    goto L159
L179:
    dec_ref r341
    goto L159
L180:
    dec_ref r370
    goto L159
L181:
    dec_ref r370
    dec_ref r373
    goto L159
L182:
    dec_ref r383
    goto L159
L183:
    dec_ref r407
    goto L159
L184:
    dec_ref r407
    dec_ref r419
    goto L159
L185:
    dec_ref r407
    dec_ref r419
    dec_ref r421
    goto L159
L186:
    dec_ref r452
    goto L159
L187:
    dec_ref r463
    goto L159
